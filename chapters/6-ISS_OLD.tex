\chapter{Instruction Set Simulator}
\label{ch:ISS}

\section{Requirements}

The following functional requirements for the ISS were collected from the previous chapters and are required for the ISS to be used as a part of the reference model. These requirements will be used throughout this chapter to discuss the choice of ISS and its necessary modifications. 

\begin{enumerate}

%\item \textbf{Provide visibility into multiple instructions} \label{issReq:visibility}
%
%\par To simulate the pipeline, we need to track multiple instructions simultaneously, corresponding to the instructions in the different pipeline stages. This requires that we can "see" the $n$ coming instructions according to the pipeline stages, or allow separation of fetching, decoding, execution, etc into separate cycles. 

\item \textbf{The ISS should be easily replaceable in the future.} \label[issReq]{issReq:replacable}

\par The ISS should be mature and thoroughly tested. It should be actively maintained and likely to be updated in the future.

\item \textbf{The ISS should be core-independent} \label[issReq]{issReq:coreIndependent}

\item[] To make the reference model modifyable to different cores, the ISS should not contain any core dependent functionality.

\item \textbf{Modify ISS to match the core.} \label[issReq]{issReq:csr}

\item[]  The ISS should be able to be modified to match the core. Specifically regarding memory mapping and CSRs.

\item \textbf{Run \acrshort{riscv} binaries generated from core-v-verif.} \label[issReq]{issReq:binaries}

\item[]  The ISS must be able to run the same binaries as the core.

\item \textbf{Support stepping through the execution at the Instruction Level} \label[issReq]{issReq:step}

\item[]  Since the reference model runs in lock-step with the DUT, we need to be able to step through the instructions at the instruction level, and be able to only run one instruction at a time, before waiting to step into the next instruction.

\item \textbf{Provide processor state after each instruction} \label[issReq]{issReq:state}

\par The ISS needs to output the state changes executed after each instruction so that the pipeline shell can apply these changes in a cycle-accurate manner. 
%To be able to use the ISS in verification, we need to access the processor state changes after each instruction to compare with the DUT. This should preferably be in the RVFI format or enough information should be available to convert into an RVFI item.

\item \textbf{Revert the state of the ISS n number of instructions} \label[issReq]{issReq:revertState}

\par As discussed in \cref{sec:app3}, if we run the ISS before the pipeline simulation, we need to be able to revert the ISS state to a previous state to simulate pipeline flushing.

%\item \textbf{Support modification of instructions} \label[issReq]{issReq:modification}
%
%\par To simulate interrupts in the pipeline, it might be necessary to simulate pipeline flushing and halting. To do this we should be able to modify the instructions in the pipeline e.g. to replace them with empty NOP operations to flush the pipeline or halt execution of an instruction. 

\item \textbf{Enable external injection of interrupts} \label[issReq]{issReq:interrupt} 

\par External interrupts and debug requests are inserted into the reference model independently of the ISS. To simulate the interrupts, we must be able to tell the ISS to take an interrupt by jumping to the trap handler's PC and correctly executing the side effects at the correct cycle. 

\item \textbf{The ISS should decide which interrupt to take, when multiple interrupts are enabled} \label[issReq]{issReq:interruptOrdering} 

\par As discussed in \Cref{sec:ps_interrupt}, which interrupt to take should be decided in the ISS instead of the pipeline shell. This means that the ISS must also know the interrupt ordering of the custom interrupts in bit 16 and above, in addition to the ordering of bit 15:0 specified in the RISC-V specification.

\item \textbf{Enable and disable interrupt independently of the \rv{mip} bits} \label[issReq]{issReq:mip} 

\par The \rv{mip} bits should be able to be set without necessarily triggering an interrupt.

\item \textbf{Support addition of custom extensions and instructions} \label[issReq]{issReq:custom}

\par A large driving force for using RISC-V is the ability to add custom extensions. Therefore, custom instructions and extensions must be easily created and added to the ISS without modifying large parts of the model.

%\item \textbf{Ensure maintainability while meeting requirements} \label[issReq]{issReq:update}
%
%\par The ISS should be easily maintained and updated while still meeting the requirements. Modifications to the ISS should be kept to a minimum and be done in a way that allows the ISS to be easily updated.

\item \textbf{Actively maintained and thoroughly tested} \label[issReq]{issReq:maintained}

\par The ISS should be mature and thoroughly tested. It should be actively maintained and likely to be updated in the future.


\item \textbf{Output CSRs relevant for interrupt timing.} \label[issReq]{issReq:CSR_timing}

\par The ISS should output the CSRs that have an influence on interrupt timing, so that these can be applied at the correct time. This includes the \rv{mstatus.mie} and \rv{mie} CSRs.

\item \textbf{Set interrupt dependent CSRs from outside of the ISS.} \label[issReq]{issReq:set_CSR}

\par We should be able to apply the effects of the \rv{mie} and \rv{mstatus} CSRs from outside of the ISS, to ensure interrupts are timed correctly.

\item \textbf{If possible, the ISS should compatible with formal verification} \label[issReq]{issReq:formal}

\par The ISS should be compatible with formal verification by being able to compile into synthesizable RTL code.
%\item \textbf{Load the same instructions as the DUT} \label[issReq]{issReq:DUTins}

%\par The ISS should be able to load the same instructions as the DUT.

%\par As discussed in \cref{sec:shell_iss_interaction}, to be able to model the reference model around an ISS, it is helpful to be able to separate the register file from the rest of the ISS, or be able to have a copy of the register file, and update the register file inside the ISS when necessary.

\end{enumerate}

\section{Choosing ISS}

The specialization project discussed multiple potential \acrshort{iss}s in \Cref{sec:pw_iss} and found that Spike \cite{SpikeRISCVISA2023} and sail-riscv \cite{RISCVSailModel2023} were the most viable choices. Both of these pass many of the requirements above, but Spike was thought to be the easiest to get started with and integrate with the rest of the pipeline shell. 

The deciding factor for us is whether any of the ISSs can meet \Cref{issReq:formal} and be synthesizable. Spike is written in C++ and is not synthesizable. 

Sail-riscv is written in the Sail language. Sail recently added support for compiling the model to SystemVerilog code\footnote{\url{https://github.com/rems-project/sail/releases/tag/0.17}}. If the model could generate synthesizable SystemVerilog code, this would meet \Cref{issReq:formal}. This feature is however still very experimental, and at the time of writing not yet implemented into the sail-riscv model\footnote{\url{https://github.com/rems-project/sail/issues/420}}.
When this feature is implemented in the future, this would be very interesting future work to implement, but for the time being, we choose to go with Spike.
We will adhere to \Cref{issReq:replacable} and make the ISS replaceable, in order to make this potential switch easy in the future


There are multiple Spike forks that we can choose to use. One potential version of Spike to use is a version that is already part of core-v-verif and is used to verify the CVA6 core from the OpenHW group. This Spike implementation is still in active development but adds some advantageous features for integrating it into the reference model.

To meet \Cref{issReq:step}, the ISS has to be able to step through the instructions, one instruction at a time. It must also output the processor state as RVFI to comply with \Cref{issReq:state}. The normal version of Spike runs sequentially, so some requirements are necessary to do this. These are the most important modifications done to the Spike version for CVA6. It implements a set of DPI function calls that are used to step through instructions in Spike and returns a simplified RVFI output \cite{openhwgroupOpenhwgroupCorevverif2023}.

These are implemented in the \file{riscv_dpi.cc} file that has DPI functions for setting parameters, initializing Spike, and stepping through the model. To maintain the state, this file has several classes instantiated as global variables, the most important being \ccode{Simulation* sim}, which is an addition made with the CVA6 Spike implementation. The \ccode{Simulation} class inherits from the spike \ccode{sim_t} class and adds a lot of the functionality implemented in the main function in pure Spike.  



\begin{table}[!htb]
\centering
%\setlist[itemize]{font= \color{DeepSkyBlue}, wide, leftmargin=*, noitemsep, after=\vspace*{-\topsep}}
%\setlength{\extrarowheight}{3pt}
%\setlength{\tabcolsep}{3pt}
\caption{Summary of advantages and disadvantages of Plain Spike and CVA6 Spike}
\label{tab:spikevsail}
%\begin{tabularx}{\textwidth}{|p{15mm}|*{2}{>{\compress\RaggedRight\arraybackslash} X |}}
\begin{tabularx}{\textwidth}{|p{15mm}|*{2}{>{\arraybackslash} X |}}
\hline
ISS & Advantages & Disadvantages \\
\hline
Plain Spike
& \begin{itemize}
\item Widely used and tested 
\item Stable 
\item Easier to keep up to date with changes to Spike
\end{itemize}
& \begin{itemize}
\item No support for RVFI outputs
\item Interrupt and debug injection must be added
\item DPI support must be added
\end{itemize} \\
\hline
CVA6 Spike
& \begin{itemize}
\item Supports a minimala version of RVFI 
\item Built into the core-v-verif
\item Already modified to work with DPI functions from systemverilog
\end{itemize}
& \begin{itemize}
\item Modified for the CVA6 Core
\item Currently in active development, so interfaces and functionality can change in the future
\item Not available in the same core-v-verif branch used by the CV32E40S/X cores which can get ugly.
\end{itemize} \\
\hline
\end{tabularx}
\end{table}







%\section{Memory regions}
%
%Spike needs to be configured to use the same memory regions as the test binaries.
%
%The binaries are generated using \lstinline{link.ld}
%
%This linkscript sets ram from \lstinline{0x00000000}
%
%by changing this to something else spike no longer complains, but the configuration of the processor changes.
%
%
%Spike configures a debug module from 0x0 to 0x1000 and a reset vector from 0x1000 to 0x2000 (REF mail. Sjekk opp). This overlaps with the memory description from link.ld and needs to be removed.
%
%
%One fix in link.ld:
%move ram to 0x80000000 and \lstinline{boot_address = 0x80000080}.
%set \lstinline{boot_addr_i = 0x80000080}.
%This kind of works, but we should modify spike instead of link.ld.




%\section{Experiment}
%
%\subsection{pure spike with cv32e40s test}
%memory 0x0 invalid
%
%\subsection{CVA6 test elf on pure spike}
%works
%
%\subsection{cva6 spike with cv32e40s test}
%memory 0x0 invalid
%
%
%\subsection{Move ram in link.ld to another location}
%Spike runs but core testbench fails




\subsection{Using CVA6 spike}

We choose to go with CVA6 spike implementation, but this also requires some modifications to be compatible with CV32E40S, and is one of the contributions of this thesis.

Some modifications to CVA6 spike are necessary
\begin{itemize}
    \item Change memory mapping to handle cv32e40s binaries 
    \item \lstinline{CV_VP_REGISTERs} are from \lstinline{0x00800000} and contain registers like virtual printer used by stdout and other thing.
    \item  disable dtb to disable the spike bootloader that overlaps with core-v memory regions
    \item Modify CSR registers
\end{itemize}




\section{Making the ISS replaceable : \Cref{issReq:replacable} }

\subsubsection{ISS interface}

To easily interface with the ISS the communication is done in \file{iss_wrap_pkg.sv}. This exports the generic functions \lstinline{iss_init()} and \lstinline{iss_step(rvfi}) that "easily" allows the ISS the be replaced in the future by only modifying \lstinline{iss_wrap_pkg.sv}. The \lstinline{iss_init()} configures Spike with the correct ISA string, sets the boot address, sets the correct parameters and loads the ELF binary. 

\lstinline{iss_step(ref st_rvfi s_reference_model}) steps spike one instruction and returns an \lstinline{st_rvfi} rvfi struct.

\textbf{Design choice:} return \sv{st_rvfi} or pass by reference into \sv{iss_step()}?

We can't pass a part of a struct by reference, so returning makes more sense.
Returning the struct makes it clearer what happens and can be used like below

\begin{systemverilog}
always_ff @(posedge clk) begin
    if(step) begin
        if_id_pipe_o.rvfi = iss_step();
        if_id_pipe_o.valid = 1'b1;
    end
    else begin
        if_id_pipe_o.rvfi = if_id_pipe_o.rvfi;
        if_id_pipe_o.valid = if_id_pipe_o.valid;
    end
end

\end{systemverilog}

\tmp{More on the interface}

\section{Matching the ISS to the core: \Cref{issReq:csr}}

\subsection{Mismatched CSRs}

There are some differences in the implementation of the CSRs from the core and Spike. These are listed below.

\begin{itemize}
    \item marchid - reset to CV32E40S marchid (\lstinline{0x15})
    \item misa - \textbf{temporary} set to \lstinline{0x40901104} to match isa. 
    \item mvendorid  - reset to \lstinline{0x602} (OpenHW mvendorid)
    \item mcountinhibit - reset to 5 instead of 0
    \item mcycle, mcycleh - Counted when they should not count. modified Spike functionality to take mcountinhibit into account
\end{itemize}

csr\_instructions fail because MPP is 11 for core and 00 for spike. 

this is from \cite{watermanRISCVInstructionSet2021}:
M-mode software can determine whether a privilege mode is implemented by writing that mode
to MPP then reading it back.
If the machine provides only U and M modes, then only a single hardware storage bit is
required to represent either 00 or 11 in MPP.

\tmp{TODO: Use parameters in spike to modify the ISS from the testbench}



\section{Load Core-v-verif binaries in Spike: \Cref{issReq:binaries}}

%\todo{bare metal. Using spike-pk?}
%
%Spike can be run with a proxy kernel or "bare metal": 
%spike-pk is a proxy kernel and boot loader. It is an execution environment that runs RISC-V ELF binaries and allows them to do system calls. It manages memory locations.

%\subsection{spike startup}
%
%describe spike startup: \url{https://github.com/riscv-software-src/riscv-isa-sim/issues/145}
%\url{https://github.com/poweihuang17/Documentation_Spike}
%
%
%
%
%\subsection{Spike with core-v-verif binary}




%\url{https://github.com/openhwgroup/core-v-verif/tree/master/cv32e40s/bsp}
The binaries used in core-v-verif is built using the \acrfull{bsp} provided with core-v-verif in \lstinline{cv32e40s/bsp}. This contains initialization tasks(\lstinline{ctr0.s}), interrupt and exception handling (\lstinline{vectors.S, handlers.S}), syscall implementations (\lstinline{syscalls.c}) and a linker script (\lstinline{link.ld}) \cite{CorevverifCv32e40sBsp}. The \acrshort{bsp} is used to compile to a bare-metal system.

The linker script has two sections, \lstinline{ram} and \lstinline{dbg}. The ram starts at \lstinline{0x0} and has a size of \lstinline{0x400000} (4MB). The debug section starts at \lstinline{0x1A110800} and has a size of \lstinline{0x1000}

When running spike with a binary generated with core-v-verif we run into problems.

Spike always starts running at the \lstinline{DEFAULT_RSTVEC = 0x1000}. Spike places a boot rom at this reset location that contains the 8 instructions long reset vector code and the binary device tree data \cite{evancoxAddDocumentationLowlevel2017}.
After this is run, spike will jump to the provided program counter or to the \lstinline{_start} symbol from the ELF file.

Aditionally, spike has a debug module in memory.

When running spike with a binary compiled with the \acrshort{bsp} we get an error saying \lstinline{memory address 0x0 is invalid}, because spikes boot rom and debug module conflicts with the corev ram. 

To avoid this conflict we can either modify the linker script to move the memory locations in the binaries, or modify spike to work with the core-v-verif binaries. By modifying \lstinline{link.ld} we also need to modify the boot address and memories of the core, but if we modify Spike, all the other components in core-v-verif can remain intact. We therefore want to modify spike to keep the core-v-verif components intact. Since we want to be able to switch out spike with another ISS, we don't want to conform to restrictions from spike.

\subsubsection{Spike modifications}

To avoid conflicts, the reset vector and debug module from spike must be disabled. Spikes default boot loader can be disabled by setting \lstinline{dtb_enabled = false} and the debug module can be removed from the \lstinline{sim_t} class.

To run the core-v-verif binaries, spike must be configured with 3 memory regions. Ram from \lstinline{0x00000000} with size \lstinline{0x400000}, Debug from \lstinline{0x1a110800} with size \lstinline{0x1000}, and corev virtual registers from \lstinline{0x00800000} with size \lstinline{0x1000}. The corev virtual registers contain registers used for example to write to stdout etc.\tmp{TODO: forklar virtual registers i bakgrunn?}

These modifications allow an elf file generated with core-v-verif to run successfully in spike.
%\subsection{linker}
%
%One notable difference between the cva6 and cv32e40s elf binary is the linking. When looking at the output of readelf for both tests, CVA6 starts at 80000000, while cv32e40s starts at 00000000. CVA6 uses the linker script at verif/tests/custom/common/test.ld. This is a proxy kernel linker script.
%
%
%I tried modifying the linker script and move the ram from 0x00000000 to 0x08000000 and the starting address to 0x08000080. By using the -m0x08000000:0x400000 spike flag the memory address ... is invalid error no longer arrives but I get a warning: warning: tohost and fromhost symbols not in ELF; can't communicate with target
%And I get this



\section{Step through individual instructions: \Cref{issReq:step}}

Pure spike runs from \lstinline{spike.cc} in the main function. The main execution is done by instantiating a \lstinline{sim_t} that gets configured with the processor and memory. The construction in \lstinline{sim_t} instantiates a configurable amount of \lstinline{prcessor_t} processor types. The original implementation from main fully runs spike until completion using the \lstinline{sim_t::run()} function.

To use Spike in the reference model, we need a way to interface with Spike to only run one instruction and return the state changes from this instruction. This requires some modification. 

We want to use DPI functions to interface with Spike from the reference model. To do this we need to instantiate spike in a dpi wrapper instead of running it from the main function. We want an initialization function that instantiates and configures spike, and a step function to step through one instruction and return the state changes as an RVFI output. We also need a function to inject interrupts into spike.

The init function should load the binary to be run, and configure the processor.

\lstinline{sim_t} has a method called \lstinline{step()} that steps through a given number of instructions in each of the configured processors. 
We can not simply instantiate a \lstinline{sim_t} object in the dpi file because this step method is private and does not return the required RVFI state changes.

One way to achieve this is to make a new class that inherits from \lstinline{sim_t} and instantiate this in the dpi wrapper. This class can publicly expose a step function that returns an RVFI output, and also abstract away some configuration details to clean up the dpi wrapper. 

In order to return an RVFI output we need to construct an RVFI item from the internal state changes in Spike. The \lstinline{processor_t} class exposes its state struct via the \lstinline{get_state()} method and this can be used to generate the rvfi item.
One problem is that the \lstinline{state_t} does not contain all necessary components to make an rvfi item, so features like the last instruction need to be added.


The CVA6 spike implementation has done just that. The CVA6 spike implementation is also integrated into core-v-verif, and if we can make this work this could be beneficial to avoid multiple versions of spike in core-v-verif for each core. This Spike version is fairly customized to the CVA6 core, so using this version also requires a good amount of modification.
This is also under development so changes can be made to this version that might break our integration in the future.

\subsection{Volatile memory regions}
\tmp{TODO: Done in imperas for example. Might affect random numbers in testbench}

\section{Return RVFI after instruction: \Cref{issReq:state}}

CVA6 spike supports outputting RVFI after each instruction, but some modifications are necessary to function properly with the CV32E40S core.

\subsection{RVFI problems}
RVFI from CVA6 is sometimes off. RVFI signals are generated by calling \lstinline{insn.rs1()} which selects the correct number of bits from the insn. This is a problem when the RISC-V format does not include this field. For example the insn \lstinline{addi x3, x3, 1224} is an I-type instruction, with only rs1 and rd registers, and not rs2. When RVFI items are generated and \lstinline{insn. rs2()} is called, it does not consider the instruction type and incorrectly stores the rs2 bits that in the case of an I-type overlap with the Imm bits, leading to an incorrect rs2 rvfi item.

\lstinline{rd1_wdata} has a mismatch when performing certain jump instructions.


\subsection{Adding the memory section to rvfi}

CV32E40S has expanded rvfi to support multiple memory operations per instructions\cite{openhwgroupRISCVFormalInterface2023}. Since all RV32I instructions support single memory operations we will implement this first.

For logging, spike stores all register and memory commits during an instruction. This can be used to generate the rd and mem rvfi signals. Register commits are stored in the unordered map \lstinline{log_reg_write} with register number and data, memory read and write commits are stored in vectors of tuples with addr, value, and size.

%To get the memory address we can use store the address into \lstinline{}
We can use these tuples to generate rvfi signals like this \tmp{TODO: legg inn kodelinje}

\subsection{rvfi interrupts and traps}

The \lstinline{rvfi_intr} signal should be asserted on the first instruction of the interrupt handler. 

For exceptions (traps), the \lstinline{rvfi_trap} signal is asserted the instruction the trap occurs, while \lstinline{rvfi_intr} is asserted on the next instruction, which is the first instruction of the trap handler. The signals of the trap and intr signals are the same, so when a trap occurs, we can store the signals to a variable \lstinline{next_rvfi_intr}. At the next step we can output this to \lstinline{rvfi_intr}.

For interrupts, we should only output \lstinline{rvfi_intr} and not \lstinline{rvfi_trap}. When taking an interrupt, spike must call the step function two times, one time to take the interrupt, and the second to actually execute the first instruction of the interrupt handler. In spike, the information about the interrupt is generated during the first step and \lstinline{taken_trap} stores if an interrupt or trap happens, and \lstinline{which_trap} holds the cause of the trap/interrupt. Aditionally the MSB of signals wether the trap is for an exception or interrupt. Since we only collect the rvfi data from the second step when taking interrupts, we generate the \lstinline{rvfi_intr} signals in the first step when the trap data is available, and store this to \lstinline{next_rvfi_intr}, which is output to \lstinline{rvfi_intr} at the next step, along with the interrupt handler.



\subsection{rvfi interface}

CVA6 spike exports an \lstinline{st_rvfi} struct which is very simplified rvfi. To add signals like \lstinline{rvfi_valid} we create a new interface called \lstinline{rvfi_if_t} that is passed from the pipeline shell to the reference model wrapper. 

\subsubsection{External interrupts}

bit 31-16


\subsubsection{Problem: differing mie in Core and Spike}

When \rv{mie} is set for all interrupts, it is set to \rv{0xFFFF0888} in the Core, but \rv{0xFFFF0aaa} in spike.
-> Priv was configured wrong (MSU instead of MU)

\section{Interrupt injection: \Cref{issReq:interrupt}}

The interrupt interface in CV32E40S has some interrupt signals tied to 0. For spike to properly simulate this we need a way to disable certain irq signals. One way to do this is to define a mask of disabled and enabled irq signals.


To insert interrupts into Spike we can define a DPI function \lstinline{spike_set_mip(irq)} to set the correct mip bits to take the interrupt. This function can be called from the \lstinline{iss_intr(irq)} systemverilog function.

In order to access the processor state in spike to set and read CSR registers, we do the actual modification of CSRs in the method \lstinline{Simulation::set_mip(reg_t mip)} in the Simulation class, which has access to the \lstinline{Processor} type where the CSRs and state is stored.

This function sets the \lstinline{mip} CSR register with the given data. The CV32E40S core only has some of the interrupt pins enabled, and some pulled to 0\cite{openhwgroupExceptionsInterruptsCOREV2023}. In order to only be able to set the wired interrupts, one solution is to use a make \lstinline{ENABLED_IRQ_MASK}, and use this when writing the mip to the CSR using \lstinline{mip->write_with_mask(ENABLED_IRQ_MASK, mip)}, to only write the wired up interrupt lines.


To precisely control when interrupts are taken from the pipeline shell, we want to both set the mip bits, and execute the first instruction of the trap handler. For spike to execute the first instruction of the trap handle, spike needs to be stepped two times after the \lstinline{mip} bits have been set. The first step only sets the correct PC and state, while the second step actually steps through the instruction. When choosing when to run these step functions there are multiple options.

We do not want to run two steps every time \lstinline{set_mip()} is called, but only when we know the interrupt will be taken at the next step. This depends on wether \lstinline{mstatus.MIE} is set to enable interrupts, if the interrupt is enabled in the \lstinline{mie} CSR, and if we are not in debug mode. We therefore need to check all of this before calling the first step function. This requires reading multiple CSR registers and the debug state. It therefore make sense to check these conditions and run the first step from inside \lstinline{Simulation::set_mip()}. Additionallly, we do not need the generated RVFI values from this step as it does not step through an instruction, so this can be discarded.

We also have to tell spike when the interrupt bits have been cleared. By checking in \lstinline{set_mip()} if the mip is not 0 before calling the step function, we can use the same method to clear the mip bits. When clearing the bits we do not want the function to step through an instruction.

In order to avoid steps when clearing mip bits we separate \lstinline{iss_intr()} and \lstinline{iss_step()}. By doing this we also avoid implementing RVFI output from \lstinline{iss_intr()} since this is not needed when it is used to clear mip bits or when interrupts are not enabled. 

In order to inject an interrupt into spike from systemverilog, we first call \lstinline{iss_intr(irq)} with the \lstinline{irq} bits to set, and the we call \lstinline{iss_step()} to step through the first instruction of the trap handler and generate the corresponding RVFI output.


\subsection{Directed Interrupt test}
\tmp{TODO: Burde disse testene under resten av seksjonen flyttes til pipeline shell istedenfor?}

To test if the pipeline shell works while implementing it, it is beneficial to have a standard directed test to use while developing the pipeline shell.
This test should fail before implementing the pipeline, but pass when it is implemented.

The core-v-verif tests use virtual peripheries to set interrupts. 
The two registers \lstinline{TIMER_REG_ADDR} and \lstinline{TIMER_VAL_ADDR} are used to set the irq value and delay to set.  

The virtual periphery reads these registers and stores the interrupt value to \lstinline{interrupt_value} or \lstinline{clic_value}, stores the timer delay, and starts the timer. This is done by calling\lstinline{interrupt_timer()} in \lstinline{uvma_obi_memory_vp_interrupt_timer_seq.sv}, which waits for the given delay, before calling \lstinline{set_interrupt()} which sets the \lstinline{irq} signal to the stored interrupt value. 

This allows tests to be written that can trigger "external" interrupts from the test code to accurately time interrupts with the code.

The first test that should pass is just passing in a simple interrupt. To do so, we first enable the MIE bit in mstatus, then enable the mie bit of the interrupt we want to set. To set the interrupt, we use \lstinline{mm_ram_assert_irq(0x1 << interrupt, 1}, which sets \lstinline{TIMER_REG_ADDR} to the mask of enabled interrupts, and \lstinline{TIMER_VAL_ADDR} to the cycle delay before asserting the interrupt.

After setting the interrupt to be triggered in 10 cycles, we do some add instructions.




\subsection{Implementation without pipeline shell}

In the first implementation, the pipeline shell is not implemented and just calls the \lstinline{step()} dpi function when the core retires an instruction. This functions correctly with synchronous execution, but not when interrupts are introduced. 

In this implementation, interrupts are inserted into the core with \lstinline{iss_intr(irq)}, which again calls \lstinline{spike_set_mip(irq)} to set the correct mip bits in spike. 
Implementation 0 calls \lstinline{iss_intr} on the first clock posedge when the \lstinline{irq_drv} signal from the interrupt interface changes.

\subsubsection{Results}

When running the Directed interrupt test with this implementation, the interrupt is taken at different times in the core and the reference model. The core executes two more instructions compared to the reference model. 


%\noindent
\begin{minipage}{.45\textwidth}
\vspace*{0pt}
\begin{lstlisting}[caption=Core,frame=tlrb]{Name}
 PC       | INSTRUCTION
 0000134c | c.lwsp x15,12(x2)
 0000134e | c.addi x15,1
 00001350 | c.swsp x15,12(x2)
 00001352 | c.lwsp x15,12(x2)
 00001354 | c.addi x15,1
 00001356 | c.swsp x15,12(x2)
 00001358 | c.lwsp x15,12(x2)
 0000000c | INTR 3
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\vspace*{0pt}
\begin{lstlisting}[caption=RM,frame=tlrb]{Name}
 PC       | INSTRUCTION
 0000134c | c.lwsp x15,12(x2)
 0000134e | c.addi x15,1
 00001350 | c.swsp x15,12(x2)
 00001352 | c.lwsp x15,12(x2)
 00001354 | c.addi x15,1
 0000000c | INTR 3
\end{lstlisting}
\end{minipage}



\subsection{Implementation with RVFI synced interrupt input}

When an interrupt is flagged with RVFI, we use \lstinline{iss_intr(irq)} to take the interrupt in spike. When setting the mip csr with the interrupt and stepping, the instructions are delayed one instruction behind the core.

When spike steps through an instruction in \lstinline{execute.cc} it first tries to take any pending interrupts with \lstinline{take_pending_interrupt()}. This will throw a \lstinline{trap_t} which will stop the execution of the current instruction and instead call \lstinline{take_trap()} which changes the PC to the trap handler and sets the state, but does not step into the first instruction of the trap handler. 

In order for \lstinline{iss_intr(irq)} to set the mip, and execute the first instruction of the trap handler, the step function in spike needs to be called two times. One time to set the state and one time to step the instruction.

By doing this the interrupt is correctly timed, but the mip is not cleared, so the interrupt is taken again.

When clearing the mip, or when setting the mip will not lead to an interrupt being taken, we do not want to step spike. It is therefore necessary to check if the interrupt will be taken before doing the extra step in spike.

\subsubsection{Results}

Spike synced with rvfi passes the custom directed test with an enabled interrupt, but fails test 1 from \lstinline{interrupt_test} which applies interrupt signals when interrupts are disabled. When reading the \lstinline{mip} CSR after it should be set to \lstinline{0x00000008}, the RM reports \lstinline{0x00000000}. This is because this implementation only sets the \lstinline{mip} CSR when the core reports taking an interrupt. Therefore when interrupt signals are applied, but interrupts are disabled, the core will not report an interrupt and the CSRs will be different.


\subsection{Async interrupts without pipeline shell }

Instead of syncing interrupts with the core using RVFI, interrupts are now passed directly into spike and are immediately taken on the next retirement from the core. This implementation is intended to highlight the problem with passing interrupts directly into the ISS.

\subsubsection{Result}

When running the directed test with interrupts passed directly into spike, we can see the trace log in \cref{lst:async_int_1}. This shows that the Interrupt is applied between \lstinline{PC=0x00001352} and \lstinline{0x00001354}. The Refference model takes the interrupt immediately at the next retirement, but the core waits 3 more retirement before jumping to the trap handler. The number of instructions delayed can also is also different depending on what instructions are in the pipeline.

\begin{lstlisting}[label={lst:async_int_1},caption={Trace output from asynchronous interrupts without pipeline shell}]

PC CORE  (INSN)     | PC RM     (INSN)
------------------------------------------
0000134e (00000785) | 0000134e, (00000785) 
00001350 (0000c63e) | 00001350, (0000c63e) 
00001352 (000047b2) | 00001352, (000047b2) 
Interrupt applied:00000008
RM Intr taken
00001354 (00000785) | 0000000c, (6b80006f) 
00001356 (0000c63e) | 000006c4, (0000b84e) 
00001358 (000047b2) | 000006c6, (fea12c23) 
Interrupt applied:00000000
Core Intr taken
0000000c (6b80006f) | 000006ca, (0000450d) 
000006c4 (0000b84e) | 000006cc, (0000c216) 
000006c6 (fea12c23) | 000006ce, (0000c01a) 
000006ca (0000450d) | 000006d0, (fe712e23) 
000006cc (0000c216) | 000006d4, (feb12a23) 
\end{lstlisting}


\subsection{Test with multiple interrupts set}

\ccode{interrupt_test - TEST 2} fails after returning from one interrupt with \rv{mret}, because the next interrupt automatically starts running in spike since the mip is already set.

We can fix this by only setting the \rv{mip} when the core will take the interrupt, and let it be 0 when this is not the case.

\textbf{New problem 1:} the fix above leads to problems when reading the CSR, since mip is not set in spike when the interrupt will not be taken.

\tmp{TODO: Fix this}
\textbf{Question:} Can we inject the \sv{interrupt_allowed} signal all the way into spike, to avoid using \ccode{mip} directly to specify if the interrupt can be taken or not?

\textbf{New problem 2:}

We do not need to flush or revert the state when one interrupt goes directly into another. 
\tmp{TODO: Find a way to detirmine if flushing/revertion needs to happen}


\textbf{Problem:} Since \sv{mret} is a few instructions ahead of the core because of the pipeline, the \rv{mstatus.mie} field goes high before and the interrupt can be taken incorrectly. By implementing the fix for the problem above, we avoid this example, but it might lead to other problems\tmp{??}


\textbf{New requirement:}

\begin{itemize}
    \item new interrupt -> revert and flush
    \item New interrupt directly after another -> no revert or flush, but take next interrupt immediately
    \item Mip CSR should be equal to the core
\end{itemize}

Solution: Add an interrupt allowed variable to spike that is set from \ccode{spike_interrupt}.

This way we do not have to use the mip to determine if the interrupt should be taken in spike or not.

We can also use the previous mip to determine if it is a new interrupt, or a interrupt after another one.

If the previous mip was 0, 

\subsubsection{interrupt allowed in spike}

Since the state is stored and reverted, we do not want to store \ccode{interrupt_allowed} inside the \ccode{state_t} struct, but instead store in it the \ccode{Processor} class. 

To set it for every clock, we can add it to \ccode{interrupt}

\section{Interrupt Ordering: \Cref{issReq:interruptOrdering}}

\subsection{test}
\textbf{Issue: Fails in TEST 2- Trigger all irqs at once}

In the example below, the state is reverted to \sv{0x0000152e}, when it should revert to \sv{0x0000152a}

\begin{terminal}
   87198.000 ns | IF 00001524  0| ID 00001520 1| EX 0000151c 0 | WB 0000151c 1 | RVFI 00000524 0|| ID 00001524  1| EX 00001520 1 | WB 0000151c 1 | RVFI 00000524 0| ia 1 / 1 | li 1 / 0 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   87201.000 ns | IF 00001524  1| ID 00001520 0| EX 00001520 1 | WB 0000151c 0 | RVFI 0000151c 1|| ID 00001528  1| EX 00001524 1 | WB 00001520 1 | RVFI 0000151c 1| ia 1 / 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | LUI      | 0000151c
   87204.000 ns | IF 00001528  0| ID 00001524 1| EX 00001520 0 | WB 00001520 1 | RVFI 0000151c 0|| ID 00001528  1| EX 00001524 1 | WB 00001520 1 | RVFI 0000151c 0| ia 0 / 0 | li 0 / 0 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   87207.000 ns | IF 00001528  1| ID 00001524 0| EX 00001524 1 | WB 00001520 0 | RVFI 00001520 1|| ID 0000152a  1| EX 00001528 1 | WB 00001524 1 | RVFI 00001520 1| ia 0 / 0 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 1 | cf 0 | sl 0 | RVFI | SW       | 00001520
   87210.000 ns | IF 0000152a  0| ID 00001528 1| EX 00001524 0 | WB 00001524 1 | RVFI 00001520 0|| ID 0000152a  1| EX 00001528 1 | WB 00001524 1 | RVFI 00001520 0| ia 0 / 0 | li 0 / 0 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   87213.000 ns | IF 0000152a  1| ID 00001528 0| EX 00001528 1 | WB 00001524 0 | RVFI 00001524 1|| ID 0000152e  1| EX 0000152a 1 | WB 00001528 1 | RVFI 00001524 1| ia 0 / 0 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 1 | cf 0 | sl 0 | RVFI | SW       | 00001524
   87216.000 ns | IF 0000152e  0| ID 0000152a 1| EX 00001528 0 | WB 00001528 1 | RVFI 00001524 0|| ID 0000152e  1| EX 0000152a 1 | WB 00001528 1 | RVFI 00001524 0| ia 0 / 0 | li 0 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
MIP set to: ffffffff
   87219.000 ns | IF 0000152e  1| ID 0000152a 1| EX 00001528 0 | WB 00001528 1 | RVFI 00001524 0|| ID 0000152e  1| EX 0000152a 1 | WB 00001528 1 | RVFI 00001524 0| ia 0 / 0 | li 0 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 1 | cf 0 | sl 0 |
   87222.000 ns | IF 00001532  0| ID 0000152e 0| EX 0000152a 1 | WB 00001528 0 | RVFI 00001528 1|| ID 00001532  1| EX 0000152e 1 | WB 0000152a 1 | RVFI 00001528 1| ia 0 / 0 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 1 | cf 0 | sl 0 | RVFI | C_SW     | 00001528
   87225.000 ns | IF 00001532  0| ID 0000152e 0| EX 0000152a 0 | WB 0000152a 0 | RVFI 00001528 0|| ID 00001532  1| EX 0000152e 1 | WB 0000152a 1 | RVFI 00001528 0| ia 1 / 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
MIP set to: 7fffffff
   87228.000 ns | IF 0000007c  0| ID 0000152e 0| EX 0000152a 0 | WB 0000152a 0 | RVFI 00001528 0|| ID 00001532  1| EX 00000000 0 | WB 00000000 0 | RVFI 00001528 0| ia 1 / 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
\end{terminal}


\tmp{TODO: Move the fail below to interrupt handling in spike}
\textbf{Issue: Fails in TEST 2- Trigger all irqs at once}

\begin{terminal}
# UVM_INFO @ 16.800 ns : uvmt_cv32e40s_base_test.sv(294) uvm_test_top [BASE TEST] set load_instr_mem
# UVM_INFO @ 17.300 ns : uvma_clknrst_if.sv(65) reporter [CLKNRST] Changing clock period to 1.500 ns
# UVM_INFO @ 114.300 ns : uvmt_cv32e40s_firmware_test.sv(178) uvm_test_top [TEST] Started RUN
# TEST 1 - TRIGGER ALL IRQS IN SEQUENCE:
# TEST 2 - TRIGGER ALL IRQS AT ONCE:
# UVM_ERROR @ 87252.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(77) reporter [RVFI_INSN] rvfi_rm.insn=170006f rvfi_core.insn=7b50006f
# UVM_ERROR @ 87252.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=40 rvfi_core.pc_rdata=7c
# UVM_ERROR @ 87252.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(101) reporter [RVFI_INTR] rvfi_rm.intr=85 rvfi_core.intr=fd
# UVM_ERROR @ 87264.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=856 rvfi_core.pc_rdata=1030
# UVM_ERROR @ 87270.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=858 rvfi_core.pc_rdata=1032
# UVM_ERROR @ 87273.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(48) reporter [Step-and-Compare] rd1_wdata core=0x0000001f and rm=0x00000010 PC=0x00001036
# UVM_ERROR @ 87273.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(77) reporter [RVFI_INSN] rvfi_rm.insn=4541 rvfi_core.insn=457d
# UVM_ERROR @ 87273.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=85c rvfi_core.pc_rdata=1036
# UVM_ERROR @ 87276.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=85e rvfi_core.pc_rdata=1038
# UVM_ERROR @ 87282.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=860 rvfi_core.pc_rdata=103a
# UVM_ERROR @ 87285.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=862 rvfi_core.pc_rdata=103c
# UVM_ERROR @ 87291.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=866 rvfi_core.pc_rdata=1040
# UVM_ERROR @ 87297.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=86a rvfi_core.pc_rdata=1044
# UVM_ERROR @ 87303.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=86e rvfi_core.pc_rdata=1048
# UVM_ERROR @ 87309.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=872 rvfi_core.pc_rdata=104c
# UVM_ERROR @ 87318.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=876 rvfi_core.pc_rdata=1050
# UVM_ERROR @ 87324.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=87a rvfi_core.pc_rdata=1054
# UVM_ERROR @ 87333.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=87e rvfi_core.pc_rdata=1058
# UVM_ERROR @ 87339.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=882 rvfi_core.pc_rdata=105c
# UVM_ERROR @ 87345.300 ns : uvmt_cv32e40s_reference_model_wrap.sv(73) reporter [RVFI_PC] rvfi_rm.pc_rdata=886 rvfi_core.pc_rdata=1060

\end{terminal}

The RM jumps to \sv{PC: 0x40 (m_fast0_irq_handler)} while the core jumps to \sv{PC: 0x7c (m_fast15_irq_handler)}

Converting the value in \sv{rvfi_intr}, we see that \sv{0x85 >> 3 => 0x10} \sv{0xfd >> 3 => 0x1f}. 
We see that the core and the ISS takes different interrupts when all interrupts are enabled.



The RISC-V specification specify the priority order of the standard interrupt bits (bit 0 to 15) in \rv{mip}, but does not specify a priority order for the custom external interrupts in bit 16 to 31 \cite{watermanRISCVInstructionSet2021}, as these can be platform specific. In CV32E40S the external interrupt with the highest ID will get the highest priority \cite{openhwgroupExceptionsInterruptsCOREV2023}.

To make the interrupt priorities the same in the core and spike we can add this to spike 

\begin{clisting}
  const bool nmie = !(state.mnstatus && !get_field(state.mnstatus->read(), MNSTATUS_NMIE));
  if (!state.debug_mode && nmie && enabled_interrupts) {
    if (enabled_interrupts & (1 << 31))
      enabled_interrupts = (1 << 31);
    else if (enabled_interrupts & (1 << 30))
      enabled_interrupts = (1 << 30);
    else if (enabled_interrupts & (1 << 29))
      enabled_interrupts = (1 << 29);
    else if (enabled_interrupts & (1 << 28))
      enabled_interrupts = (1 << 28);
    else if (enabled_interrupts & (1 << 27))
      enabled_interrupts = (1 << 27);
    else if (enabled_interrupts & (1 << 26))
      enabled_interrupts = (1 << 26);
    else if (enabled_interrupts & (1 << 25))
      enabled_interrupts = (1 << 25);
    else if (enabled_interrupts & (1 << 24))
      enabled_interrupts = (1 << 24);
    else if (enabled_interrupts & (1 << 23))
      enabled_interrupts = (1 << 23);
    else if (enabled_interrupts & (1 << 22))
      enabled_interrupts = (1 << 22);
    else if (enabled_interrupts & (1 << 21))
      enabled_interrupts = (1 << 21);
    else if (enabled_interrupts & (1 << 20))
      enabled_interrupts = (1 << 20);
    else if (enabled_interrupts & (1 << 19))
      enabled_interrupts = (1 << 19);
    else if (enabled_interrupts & (1 << 18))
      enabled_interrupts = (1 << 18);
    else if (enabled_interrupts & (1 << 17))
      enabled_interrupts = (1 << 17);
    else if (enabled_interrupts & (1 << 16))
      enabled_interrupts = (1 << 16);
    //// nonstandard interrupts have highest priority
    //if (enabled_interrupts >> (IRQ_M_EXT + 1))
    //  enabled_interrupts = enabled_interrupts >> (IRQ_M_EXT + 1) << (IRQ_M_EXT + 1);
    // standard interrupt priority is MEI, MSI, MTI, SEI, SSI, STI
\end{clisting}

This solves the priority issues in spike.



\section{Problem: correct timing of side effects}

\subsubsection{Example: \rv{mret} changing \rv{mstatus} early}

Since spike runs a few instructions ahead of the core, some side effects are also executed too early.

One instance where this causes a problem is when one interrupt handler finishes and another interrupt is taken immediately. When \rv{mret} runs in spike ahead of the core, it reactivates \rv{mstatus.mie} a few cycles ahead of the core. If \sv{interrupt_allowed} is high in the period after spike has set \rv{mstatus.mie} high, but before this has happened in the core, spike will take the interrupt, but the core will wait because it has not set \rv{mstatus.mie} high yet.

\tmp{TODO: Determine if csrs should be delayed}
\tmp{TODO: Delay all, delay some, or find a way to execute them directly, but find a way to read the value a number of retirements ago for the needed CSRs(mstatus) }

\tmp{TODO: Kan spesifikt mstatus.mie eksporteres fra ISSen, gå gjennom pipeline, og brukes sammen med \sv{interrupt_allowed} for å sette interrupts} Ja tror det. 
\tmp{TODO: Lagre CSR i et eget reg i pipeline shellet. Men da må revert state kjøres helt fra pipeline shell og ikke i \sv{spike_interrupt}, som kanskje er en god ting...}



\subsubsection{Situation:}
\begin{enumerate}
    \item insn N
    \item insn N+1
    \item mret (interrupt not allowed, but mip is 0x7fff0000)
    \item insn
    \item insn
    \item insn
    \item insn (interrupt allowed)
    \item take interrupt
\end{enumerate}

in this situation we cant take the new interrupt immediately, but have to wait for interrupt allowed.


\tmp{Question: What side effects are triggered before WB, and what are the consequences?}

\subsubsection{Problems:}
\begin{itemize}
    \item 
\end{itemize}

\textbf{CM.PUSH fails by 16 (50 instead of 60).} This means stack pointer is not the same. The root cause is reverting the wrong amount of steps.


\section{Revert state: \Cref{issReq:revertState}}

To revert spike to a previous state there are some options.

Since spike executes the entire instruction before entering the pipeline, spike has already executed instructions that might need to be discarded because of a pipeline flush. We therefore need a way to revert changes made in spike for instructions that are still in the pipeline.

The operations that need to be reverted are writes to the register file, writes to \acrshort{csr}s, and writes to the memory \cite{}.

We have some options:
\begin{itemize}
    \item Store full state in pipeline shell
    \item Revert based on state changes stored in pipeline shell
    \item Store x previous states in spike, and revert
\end{itemize}

Spike has a struct called \ccode{state_t} that contains the PC, registers, and csrs. This can be stored to revert the state. 

If memory writes have been executed during the execution, it gets more complicated, as this is not stored int the \ccode{state_t} struct. To handle we must either find a way to store the memory for each instruction, figure out if only the cache or tlb\textbf{????} can be stored, or store the values before a change than can be stored back into memory.







\subsubsection{Spike memory}

%\url{https://github.com/poweihuang17/Documentation_Spike?tab=readme-ov-file#Memory}

On a store instruction like \rv{sw} the following is executed in spike \ccode{MMU.store<uint32_t>(RS1 + insn.s_imm(), RS2);} which translates to \ccode{*p->get_mmu().store(RS)}. This returns the \ccode{mmu_t* mmu} from \ccode{processor_t}.

The store method checks the TLB and stores the value with \ccode{store_slow_path} and \ccode{store_slow_path_intrapage()} which actually stores the value using \ccode{memcpy(host_addr, bytes, len);}. The \ccode{host_addr} is either found in the TLB or calulated and inserted if not in the TLB. 


The memory regions like ram are created with \ccode{this->mems.push_back(std::make_pair(dram_base, new mem_t(dram_size)));}
which creates a new \ccode{mem_t}. This contains a memory map \ccode{std::map<reg_t, char*> sparse_memory_map;}

Storing to memory involves using \ccode{memcpy} with an address from \ccode{mem_t::contents(reg_t addr)}
This searches the \ccode{sparse_memory_map} to find the key value pair with the page the address is on. If the address is not in the \ccode{sparse_memory_map}, it allocates a page using \ccode{auto res = (char*)calloc(PGSIZE, 1);}, adds this to the \ccode{sparse_memory_map} and returns the address as \ccode{page + pageoffset}.

\subsubsection{Storing a copy of memory for every instructions}

The use of the \ccode{sparse_memory_map}, storing the location of memory pages, it makes it somewhat difficult to store multiple versions of the memory along with each instruction in the pipeline. Simply copying the memory map is not enough as it does not hold the actual values. Instead is is necessary to copy each page of the memory map into another memory map and allocate space for these individually. 

Additionally the TLB also has to be updated.

This gets even more complicated when using a cache, as this also has to be correctly updated and reverted. 


\subsubsection{Storing the changes to memory for every instruction. (or values before memory operation)}

A more general and less implementation specific approach could be to store the values in a memory location before it is being written to. This must be kept while the instruction that executed the memory operation is in the pipeline. When the pipeline is flushed, each of these memory operations has to be reverted back to its original state. This allows us to use the top level memory interface, which would automatically handle the TLB, caches, and storing to the correct memory address on the correct page.

The \ccode{state_t} already contais commit logs holding reads and writes to registers and memory, used to make the execution log from spike. The memory logs hold address, value, and size on the form \ccode{typedef std::vector<std::tuple<reg_t, uint64_t, uint8_t>> commit_log_mem_t;} from \file{processor.h}. The commit log is written to in \ccode{store()} in \file{mmu.h}.

We are interested in the value before writing, and not the value stored in the commit log, which is the value after writing. 

We can therefore expand the \ccode{state_t} to hold a commitlog of values before writing called \ccode{log_mem_pre_write} and store to that in the \ccode{store} function.

To load the memory values before writing to them, we can either use the \ccode{load()} function from inside \ccode{store()} or directly use the relevant lines from \ccode{load()} in \ccode{store()}. If we were to call the \ccode{load()} function, this would also store to the \ccode{log_mem_read} commit log, which would affect the generated RVFI output and spike execution log. We would therefore have to clear the \ccode{log_mem_read} after running \ccode{load()} or disable the commit log before running it.

Since the address generation from \ccode{load()} and \ccode{store()} are similar, we can easily add the relevant lines of code from \ccode{load()} to \ccode{store()}. The expanded \ccode{store()} from \file{mmu.h} is shown in \Cref{lst:store} with the added lines marked with \ccode{+}.


\begin{clisting}[caption={Modified \ccode{store()} function from \file{mmu.h} with new lines marked with \ccode{+}.}, label={lst:store}]
  template<typename T>
  void ALWAYS_INLINE store(reg_t addr, T val, uint32_t xlate_flags = 0) {
    reg_t vpn = addr >> PGSHIFT;
    bool aligned = (addr & (sizeof(T) - 1)) == 0;
    bool tlb_hit = tlb_store_tag[vpn % TLB_ENTRIES] == vpn;
    target_endian<T> previous_value;


    if (xlate_flags == 0 && likely(aligned && tlb_hit)) {
+     //Store previous value before writing
+     previous_value = *(target_endian<T>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr);

      *(target_endian<T>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val);
    } else {
+     //Store previous value before writing
+     load_slow_path(addr, sizeof(T), (uint8_t*)&previous_value, xlate_flags);

      target_endian<T> target_val = to_target(val);
      store_slow_path(addr, sizeof(T), (const uint8_t*)&target_val, xlate_flags, true, false);
    }

    if (unlikely(proc && proc->get_log_commits_enabled())) {
      proc->state.log_mem_write.push_back(std::make_tuple(addr, val, sizeof(T)));
+     proc->state.log_mem_pre_write.push_back(std::make_tuple(addr, from_target(previous_value), sizeof(T)));
    }
  }
\end{clisting}



\subsubsection{Storing states for instructions}

Since we store the \ccode{log_mem_pre_write} in the \ccode{state_t} it should be sufficient to only store this state struct for each instruction in the pipeline to store the registers, \acrshort{csr}s, and memory operation for each instruction. 

To avoid converting this struct to systemverilog, and back to C++, it is easier to store this state \textit{snapshots} in Spike, and use a DPI function call from the pipeline shell to signal which snapshot to revert back to.

Because we only need the states for the instructions that are currently in the pipeline, we only need to store a set number of previous states. If we in the future want to use a synthesizable ISS, this method can be advantageous as fixed size array is easier to synthesize than a dynamic array.

In Spike we can store the previous states in a \ccode{deque} double-ended queue. This makes it easy to insert the most recent state at the beginning of the queue, and remove the oldest state from the end of the queue when the instruction leaves the pipeline. 
We can also easily access items at a specific index to revert the state to a given previous state.

\tmp{Where to store state}


\tmp{When to store state}

\subsubsection{Problem: CSRs are not stored individually for each state??}

CSRs are written with \ccode{processor_t::put_csr(int which, reg_t val)}. This writes to the CSR stored in \ccode{state.csrmap}

The \ccode{mstatus} csr is stored as a \ccode{shared_ptr}, which means that when we copy the struct into the deque, we only copy the pointer and not the actual CSR value.

\tmp{Choice:}We must either deep copy all the CSR values in \ccode{csrmap} or use the commit log for registers, which also contains csr writes. 

\tmp{Investigate: new CVA6 csr output} uses c



\tmp{TODO: Implement}





\subsection{Reverting state}

The order of events when reverting the state is important to get right.
If this is the order

\begin{enumerate}
    \item Interrupt input into RM
    \item Spike mip set to irq. Returns if interrupt will be taken
    \item Revert spike state
    \item Flush pipeline shell
\end{enumerate}

In the example above, the mip, pc, cause, status, etc set with \ccode{spike_set_mip()} is overwritten when reverting the state. We should either store the mip, revert the state, then store back the mip, or revert the state before setting the mip.


If we revert the state before setting the mip, we get the following order:

\begin{enumerate}
    \item Interrupt input into RM
    \item Determine if interrupt will be taken with the incoming interrupt
    \item - Revert spike state if interrupt will be taken 
    \item Spike mip set to irq
    \item Flush pipeline shell
\end{enumerate}

Item 2,and 4 are currently done in \ccode{spike_set_mip}.
To revert the state before setting the mip, we need a way of determining if the interrupt will be taken before setting the mip. 

\textbf{Design choice:} Revert state in \ccode{spike_set_mip()} or divide this into multiple functions: \ccode{spike_will_interrupt_be_taken(mip)}, \ccode{spike_revert_state(num_states)}, \ccode{spike_set_mip(mip)} etc.

The amount of steps to revert depends on information in the pipeline shell, so we must either pass the amount of steps to revert into \ccode{spike_set_mip()} or into \ccode{spike_revert_state(num_states)}.

%\tmp{make sure memory is reverted properly}
%
%\tmp{make sure mepc is set correctly after rewrite}

\section{Custom instructions:\Cref{issReq:custom}}

\tmp{ZCMP supports multiple memory operations per instruction. This affects RVFI}

\tmp{Also supports multiple RD writes, which must also be handled with RVFI}

%\section{Update: \Cref{issReq:update}}

\section{Problems and solutions}

\begin{enumerate}

\item \textbf{Issue:} \lstinline{mem_rdata} is 0 when using \lstinline{mem_read_commits}
  \begin{description}
    \item[Cause:] Spike only stores the address of memory reads, but stores both address and value for writes.
    \item[Resolution:] [Spike] The read value should be the same as rd, so we can use the rd value as the memory read value.
  \end{description}

\item \textbf{Issue:} Wrong address with multiple memory accesses in one instruction. This is a problem with Zcmp.
  \begin{description}
    \item[Temporary Fix:] [Compare] Disable for now. \textbf{TODO:} Handle multiple memory accesses.
  \end{description}

\item \textbf{Issue:} \lstinline{mem_rdata} mismatch between RM and Core
  \begin{description}
    \item[Resolution:] [Compare] Only the \lstinline{mem_wdata} and \lstinline{mem_rdata} bytes that are high in \lstinline{mem_(w/r)mask} should be compared, as the other bytes can be different.
  \end{description}

\item \textbf{Issue:} \lstinline{rd1_wdata} is sometimes mismatched
  \begin{description}
    \item[Cause:] When \lstinline{rd1_addr} is 0, \lstinline{rd1_wdata} data is not guaranteed to be 0.
    \item[Resolution:] [Compare] Only check \lstinline{rd1_wdata} if the address is not 0.
  \end{description}

\item \textbf{Issue:} \lstinline{csr_priv_gen_test} insn mismatch at PC \lstinline{0x00000000}

\item \textbf{Issue:} Trap mismatch for illegal instruction type
  \begin{description}
    \item[Cause:] Spike generated wrong rvfi for trap.
    \item[Resolution:] [Spike] Generate correct trap rvfi in spike.
  \end{description}

\item \textbf{Issue:} Interrupt mismatch
  \begin{description}
    \item[\textbf{TODO:}] Interrupt rvfi must be added. The \lstinline{intr} signal must be delayed until the first instruction of the interrupt handler.
  \end{description}

\item \textbf{Test:} \lstinline{cv32e40s_readonly_csr_access_test}:
  \begin{description}
    \item[Issue:] \lstinline{rd1_addr} mismatch on \lstinline{csrrs} instruction causing trap.
    \item[Cause:] TODO
    \item[Resolution:] [Compare] Ignore \lstinline{rd1_addr} on trap.
  \end{description}

\item \textbf{Test:} \lstinline{cv32e40s_csr_access_test}:
  \begin{description}
    \item[Issue:] In the core \lstinline{mcycle} is 0 after 3 instructions, but in Spike it is 3.
    \item[Cause:] \lstinline{mcountinhibit} is 0 in RM and 5 in core and \lstinline{mcycle} is increased regardless of \lstinline{mcountinhibit}
    \item[Resolution1:] [Spike] Reset \lstinline{mcountinhibit} to 5 like in the core.
    \item[Resolotion2:] [Spike] Check if the \lstinline{mcountinhibit} bit is high before increasing (or not) \lstinline{mcycle} in spike.
  \end{description}

\item \textbf{Issue:} \lstinline{mcycleh} is 2 when core is 0
  \begin{description}
    \item[Cause:] Spike has "hack" to add one on write to take into account the coming bump of \lstinline{mcycle} \texttt{FFFFFFFF}.
    \item[Resolution:] \textbf{FIX(ish):} Revert a hack that adds 1 to account for upcoming bump. TODO: make sure modifications work for all cases.
  \end{description}

\item \textbf{Issue:} \lstinline{mstatus} mismatch \lstinline{core = 0x00201880 and rm = 0x00200080}
  \begin{description}
    \item[Problem:] The difference is \lstinline{MPP = 3} for core and 0 for RM.
    \item[\textbf{TODO:}] \tmp{This is not solved yet}
  \end{description}
  
\item \textbf{Issue:} CSRs are wrong in hello world test
  \begin{description}
    \item[Cause:] CSRs (\lstinline{marchid, misa, mvendorid, and mimpid}) are configured differently in spike and core
    \item[Resolution:] Change CSRs in \lstinline{state_t::reset()} in \lstinline{processor.cc}.
  \end{description}
  
\item \textbf{Issue:} RVFI mismatch: cm.popret reports rd1 = x0 from core but rd1 = x2 from RM 
  \begin{description}
    \item[Cause:] RVFI reporting is done differently
    \item[Resolution:] [Spike] Check if the instruction is a popret instruction and set rd1 to 0 if it is in 
  \end{description}

\item \textbf{Issue:} When setting all mie bits in spike, only bit 3, 7, and 11 are set. Bit 16-30 used for custom interrupts are not set 
  \begin{description}
    \item[Cause:] The \lstinline{csrrw} instruction writes a csr with a mask. The mask for writing to \lstinline{mie} is generated using \lstinline{reg_t mie_csr_t::write_mask} in \lstinline{csrs.cc}. This does not enable all custom interrupt bits(16-31) like the core does.
    \item[Resolution:] [Spike] Add custom interrupt bits (16-31) to mie write mask in spike
  \end{description}
  

\item \textbf{Issue:} RVFI intr signal is incorrectly timed. The trap signal should be active when the trap arrives, but the intr signal should be active on the first instruction of the trap handler.
  \begin{description}
    \item[Cause:] 
    \item[Resolution:] [Spike] Store the rvfi trap signal until the next step, when the rvfi intr signal is set to the previous trap signal
  \end{description}

\item \textbf{Issue:} Differentiate between trap and interrupt to output correct rvfi.intr signal.
  \begin{description}
    \item[Cause:] When spike takes an interrupt it throws a \lstinline{trap_t(cause)} and sets the msb of cause to 1 to show the trap is an interrupt. When a synchronous trap is encountered, the cause is not marked with the high msb. This cause is stored in the \lstinline{which_trap} variable in the \lstinline{Processor} class, but this is stored as an \lstinline{uint8_t}, which discards the information stored in the msb.
    \item[Resolution:] [Spike] By changing \lstinline{which_trap} to an \lstinline{uint32_t} we can differentiate between interrupts and traps when building the rvfi signals.
  \end{description}

\item \textbf{Issue:} Mip sometimes not being set to 0 in spike
  \begin{description}
    \item[Cause:] in \ccode{set_mip}, we don't get to set mip to 0 if \sv{mstatus.mie} is 0
    \item[Resolution:] [Spike] Make \ccode{will_take_interrupt(mip)} function to make it more clear
  \end{description}

\item \textbf{Issue:} State revertion of memory writes caused alignment error
  \begin{description}
    \item[Cause:] When reverting state the memory would always be stored as \ccode{uint64_t}
    \item[Resolution:] [Spike] Make a switch case to cast the correct variable size 
  \end{description}

  
\end{enumerate}

\section{WFI}

As of commit cf23fb7a, when spike runs a wfi insntruction, spike stops running.
When spike runs \rv{wfi} instruction, it sets the next PC and throws a \ccode{wait_for_interrupt_t} exception.

A wfi should stop waiting when an interrupt occurs, even though \rv{mstatus.mie} is disabled\cite{}. The \ccode{interrupt_allowed} bool we added should not block \ccode{take_interrupt(pending_interrupt)} from running even if interrupts are not allowed, since this could lead to a \rv{wfi} not waking up when an interrupt is passed to spike.

Another problem with \rv{wfi} instructions and the pipeline shell is that when a wfi is set in spike, the step will abort and only return the same wfi instruction, eventually filling up all the pipeline stages with the same interrupt \rv{wfi} instruction. 

To allow the pipeline to fill up with the upcoming instructions after the \rv{wfi}, we can disable wfi in Spike by setting \ccode{in_wfi = false} in the step function in \file{Proc.cc}. This way, the next instruction will run on the next step, and we will have to make sure \rv{wfi} waits operate as intended outside of Spike in the reference model. When using the retirement dependent approach, the \rv{wfi} instruction will automatically wait to be run until the core runs, but we need some way to determine that an interrupt actually occurred, causing the execution to continue after the \rv{wfi}. \tmp{TODO: this}


\tmp{TODO: CSR mie read after write}
\subsection{divu}

divu valid
0
0
0
0
0
0 intr taken
0
0
0
0
0
0
40



\subsection{addi}

addi valid
addi valid
addi valid
0   intr taken
0
0
40

\subsection{wfi}

0 (wfi)
0
0
0
0 debug taken
wfi valid
0
0
0
0
0
0
0
debug handler


\section{Debug requests}

Asyncronous debug requests have many similarities to interrupts, but also some differences.

One timing difference between interrupts and debug requests in the CV32E40S core is that when an interrupt is taken, the pipeline is immediately flushed and the PC changed to the interrupt handler, while when an async debug is taken, the pipeline is first halted one cycle, before flushing all or parts of the pipeline the next cycle. The WB stage is not flushed if the interrupt is caused by \rv{EBREAK} or \rv{TRIGGER}


\subsection{RVFI}

All instruction run in debug mode should output \ccode{rvfi_dbg_mode = 1}, and the first debug instruction should output the debug cause in \ccode{rvfi_dbg} \cite{openhwgroupRISCVFormalInterface2023}.


\subsection{\rv{dcsr}}

The \rv{dcsr} debug control and status CSR differs between the core and spike. The core has the \rv{MPRVEN} and \rv{STOPCYCLE} fields hardwired to 1, while these are hardwired to 0 in Spike. Both these fields are specified as optional in the RISC-V Debug Specification \cite{pauldonahueRISCVDebugSupport2023}, so these field should be configurable in spike to match different cores.



\subsection{Two debug requests after eachother}

We get the same problem when a debug request returns from debug mode with \rv{dret} and goes straight into another debug request, as when an interrupt returns from the interrupt handler with \rv{mret} and takes another interrupt. The problem here is that Spike runs a few instructions ahead, and applied the side effects of the \rv{dret} instruction prematurely, causing the \sv{iss_set_debug()} function to set \sv{debug_taken} and flush the pipeline prematurely.

For interrupts, this is solved by exporting the relevant CSRs through RVFI, passing them through the pipeline, and using these to correctly time the changes.

\rv{dret} restores the PC and privileged to the values stored in \rv{dpc} and \rv{dcsr}, and exits debug mode. The side effect that influences the timing of debug requests is that \ccode{debug_mode} is turned off in \rv{dret}. the \ccode{debug_mode} is used by the \ccode{set_debug} method to determine if a new debug request can be made, or if the processor is currently in the debug mode. We must therefore delay this signal to when the pipeline shell is out of debug mode, and not only when spike has exited debug mode. 

The debug mode is output to RVFI via the \sv{rvfi_dbg_mode} signal. One solution is therefore to use this to update a copy of \sv{debug_mode} in the pipeline shell. One problem with this is that the \sv{rvfi_dbg_mode} reports high when in \rv{dret} since the instruction is run in debug mode, but since \rv{dret} disables debug mode, we want to set our local copy to 0 when the \rv{dret} instruction leaves WB. 

\tmp{TODO: solve this. Pass a separate dbg mode signal through the stages, update internally in spike with saved states, or have a special "if dret" signal to set debug mode to 0}

\subsection{EBREAK in pipeline when external debug request is enabled}

when ebreak runs in IF, spike sets debug mode to 1. This causes problems for a debug request that is asserted while the \rv{ebreak} is in the pipeline, but not yet executed in WB. Since the ISS already is in debug mode caused by the \rv{ebreak}, the debug request would not be taken, and the cause of the debug mode would be the \rv{ebreak} instead of the external debug request which has higher priority. To fix this, we can modify \ccode{set_debug()} to check if a new debug request is done while debug is allowed, and the current debug cause is by an \rv{ebreak}. If this is the case, we can disable debug mode, so that the external debug request can trigger debug mode again with the correct cause.


\subsection{debug at the very start}

Debug asserted from the beginning causes problems with state rollback.


\subsection{State revertion}

Spike must be reverted the same way as when an interrupt is taken, so at the end of \ccode{set_debug()} we revert the state of spike by the given number of revert steps.



\section{interrupts and debug}

\subsection{priorotizing events}

\begin{enumerate}
    \item nmi
    \item async debug
    \item interrupt
    \item sync debug
    \item normal execution
    \begin{enumerate}
        \item exception
        \item wfi
        \item fencei
        \item dret
        \item csr write
        \item csr flush
        \item branch
        \item jump
        \item clic ptr or meet ptr
    \end{enumerate}
\end{enumerate}

\subsection{Complications}

\subsubsection{Interrupt after \rv{dret}}