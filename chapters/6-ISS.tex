\chapter{Instruction Set Simulator (ISS)}
\label{ch:ISS}

%\tmp{Burde jeg delt opp kapittelet tydeligere i: 1. Adding CV32E40S support to spike, og 2. Modifications to support pipeline shell??}

The \acrfull{iss} is a critical component in our reference model, responsible for the functional execution of each instruction While the pipeline shell handles the timing and core-specific pipeline behaviour, the ISS ensures the correct interpretation and execution of the instructions according to the RISC-V ISA specification \cite{watermanRISCVInstructionSet2019, watermanRISCVInstructionSet2021}.

This chapter will discuss the selection and modification of the iSS to meet the requirements of our reference model. cover the necessary modifications to the ISS to integrate it with the rest of the design. The key contributions in this chapter can be categorized into two main areas:

\begin{enumerate}
    \item Modifying the ISS to support the CV32E40S processor core.
    \item Modifying the ISS to ensure proper interaction with pipeline shell.
\end{enumerate}

\section{ISS Requirements}

To achieve these goals, we define the following requirements for the ISS. These requirements are collected from the previous chapters and referred to as \textbf{ISS Requirement X}.


and are required for the ISS to be used as a part of the reference model. This chapter will use these requirements to discuss the choice of ISS and its necessary modifications. 

\begin{enumerate}

%\item \textbf{Provide visibility into multiple instructions} \label{issReq:visibility}
%
%\par To simulate the pipeline, we need to track multiple instructions simultaneously, corresponding to the instructions in the different pipeline stages. This requires that we can "see" the $n$ coming instructions according to the pipeline stages, or allow separation of fetching, decoding, execution, etc into separate cycles. 

\item \textbf{The ISS should be easily replaceable in the future.} \label[issReq]{issReq:replacable}

\par The ISS should be mature and thoroughly tested. It should be actively maintained and likely to be updated in the future.

\item \textbf{The ISS should be core-independent} \label[issReq]{issReq:coreIndependent}

\item[] The ISS should contain as little core-dependent functionality as possible to make the reference model easily modifiable to different cores.

\item \textbf{Modify ISS to match the core.} \label[issReq]{issReq:csr}

\item[]  The ISS should be able to be modified to match the core. Specifically regarding memory mapping and CSRs.

\item \textbf{Run \acrshort{riscv} binaries generated from core-v-verif.} \label[issReq]{issReq:binaries}

\item[]  The ISS must be able to run the same binaries as the core.

\item \textbf{Support stepping through the execution at the Instruction Level} \label[issReq]{issReq:step}

\item[]  Since the reference model runs in lock-step with the DUT, we need to be able to step through the instructions at the instruction level, and be able to only run one instruction at a time, before waiting to step into the next instruction.

\item \textbf{Provide processor state after each instruction} \label[issReq]{issReq:state}

\par The ISS needs to output the state changes executed after each instruction so that the pipeline shell can apply these changes in a cycle-accurate manner. 
%To be able to use the ISS in verification, we need to access the processor state changes after each instruction to compare with the DUT. This should preferably be in the RVFI format or enough information should be available to convert into an RVFI item.

\item \textbf{Revert the state of the ISS a variable number of instructions} \label[issReq]{issReq:revertState}

\par To discard instructions flushed in the pipeline, we must be able to revert the ISS to a previous state, as discussed in \Cref{sec:ps_revertion}. We must be able to revert the \acrshort{pc}, \acrshort{gpr}, \acrshort{csr}, and memory operations a set number of steps.


%\item \textbf{Support modification of instructions} \label[issReq]{issReq:modification}
%
%\par To simulate interrupts in the pipeline, it might be necessary to simulate pipeline flushing and halting. To do this we should be able to modify the instructions in the pipeline e.g. to replace them with empty NOP operations to flush the pipeline or halt execution of an instruction. 

\item \textbf{Enable external injection of interrupts} \label[issReq]{issReq:interrupt} 

\par External interrupts and debug requests are inserted into the reference model independently of the ISS. To simulate the interrupts, we must be able to tell the ISS to take an interrupt by jumping to the trap handler's PC and correctly executing the side effects at the correct cycle. 

\item \textbf{The ISS should decide which interrupt to take, when multiple interrupts are enabled} \label[issReq]{issReq:interruptOrdering} 

\par As discussed in \Cref{sec:ps_interrupt}, which interrupt to take should be decided in the ISS instead of the pipeline shell. This means that the ISS must also know the interrupt ordering of the custom interrupts in bit 16 and above, in addition to the ordering of bit 15:0 specified in the RISC-V specification.

\item \textbf{Enable and disable interrupt independently of the \rv{mip} bits} \label[issReq]{issReq:interruptEnabled} 

\par The \rv{mip} bits should be able to be set without necessarily triggering an interrupt.

\item \textbf{Configurable with different extextions} \label[issReq]{issReq:custom}

\par A large driving force for using RISC-V is the ability to add custom extensions. Therefore, custom instructions and extensions must be easily created and added to the ISS without modifying large parts of the model.

%\item \textbf{Ensure maintainability while meeting requirements} \label[issReq]{issReq:update}
%
%\par The ISS should be easily maintained and updated while still meeting the requirements. Modifications to the ISS should be kept to a minimum and be done in a way that allows the ISS to be easily updated.

%\item \textbf{Actively maintained and thoroughly tested} \label[issReq]{issReq:maintained}

%\par The ISS should be mature and thoroughly tested. It should be actively maintained and likely to be updated in the future.


\item \textbf{Output CSRs relevant for interrupt timing.} \label[issReq]{issReq:CSR_out}

\par The ISS should output the CSRs that have an influence on interrupt timing, so that these can be applied at the correct time. This includes the \rv{mstatus.mie} and \rv{mie} CSRs.

\item \textbf{Set interrupt dependent CSRs from outside of the ISS.} \label[issReq]{issReq:set_CSR}

\par We should be able to apply the effects of the \rv{mie} and \rv{mstatus} CSRs from outside of the ISS, to ensure interrupts are timed correctly.

\item \textbf{[optional] The ISS should compatible with formal verification} \label[issReq]{issReq:formal}

\par The ISS should be compatible with formal verification by being able to compile into synthesizable RTL code.
%\item \textbf{Load the same instructions as the DUT} \label[issReq]{issReq:DUTins}

%\par The ISS should be able to load the same instructions as the DUT.

%\par As discussed in \cref{sec:shell_iss_interaction}, to be able to model the reference model around an ISS, it is helpful to be able to separate the register file from the rest of the ISS, or be able to have a copy of the register file, and update the register file inside the ISS when necessary.

\end{enumerate}

\section{Choosing ISS}

The specialization project discussed multiple potential \acrshort{iss}s in \Cref{sec:pw_iss} and found that Spike \cite{SpikeRISCVISA2023} and sail-riscv \cite{RISCVSailModel2023} were the most viable choices. Both of these pass many of the requirements above, but Spike was thought to be the easiest to get started with and integrate with the rest of the pipeline shell. 

The deciding factor for us is whether any of the ISSs can meet \Cref{issReq:formal} and be synthesizable. Spike is written in \cpp and is not synthesizable. 

Sail-riscv is written in the Sail language. Sail recently added support for compiling the model to SystemVerilog code\footnote{\url{https://github.com/rems-project/sail/releases/tag/0.17}}. If the model could generate synthesizable SystemVerilog code, this would meet \Cref{issReq:formal}. This feature is however still very experimental, and at the time of writing not yet implemented into the sail-riscv model\footnote{\url{https://github.com/rems-project/sail/issues/420}}.
When this feature is implemented in the future, this would be very interesting future work to implement, but for now, we choose to go with Spike.
We will adhere to \Cref{issReq:replacable} and make the ISS replaceable, in order to make this potential switch easy in the future


There are multiple Spike forks that we can choose to use. One potential version of Spike to use is a version that is already part of core-v-verif and is used to verify the CVA6 core from the OpenHW group. This Spike implementation is still in active development but adds some advantageous features for integrating it into the reference model.

To meet \Cref{issReq:step}, the ISS has to be able to step through the instructions, one instruction at a time. It must also output the processor state as RVFI to comply with \Cref{issReq:state}. The normal version of Spike runs sequentially, so some requirements are necessary to do this. These are the most important modifications done to the Spike version for CVA6. It implements a set of DPI function calls that are used to step through instructions in Spike and returns a simplified RVFI output \cite{openhwgroupOpenhwgroupCorevverif2023}.

These are implemented in the \file{riscv_dpi.cc} file that has DPI functions for setting parameters, initializing Spike, and stepping through the model. To maintain the state, this file has several classes instantiated as global variables, the most important being \ccode{Simulation* sim}, which is an addition made with the CVA6 Spike implementation. The \ccode{Simulation} class inherits from the spike \ccode{sim_t} class and adds a lot of the functionality implemented in the main function in pure Spike.  



\begin{table}[!htb]
\centering
%\setlist[itemize]{font= \color{DeepSkyBlue}, wide, leftmargin=*, noitemsep, after=\vspace*{-\topsep}}
%\setlength{\extrarowheight}{3pt}
%\setlength{\tabcolsep}{3pt}
\caption{Summary of advantages and disadvantages of Plain Spike and CVA6 Spike}
\label{tab:spikevsail}
%\begin{tabularx}{\textwidth}{|p{15mm}|*{2}{>{\compress\RaggedRight\arraybackslash} X |}}
\begin{tabularx}{\textwidth}{|p{15mm}|*{2}{>{\arraybackslash} X |}}
\hline
ISS & Advantages & Disadvantages \\
\hline
Plain Spike
& \begin{itemize}
\item Widely used and tested 
\item Stable 
\item Easier to keep up to date with changes to Spike
\end{itemize}
& \begin{itemize}
\item No support for RVFI outputs
\item Interrupt and debug injection must be added
\item DPI support must be added
\end{itemize} \\
\hline
CVA6 Spike
& \begin{itemize}
\item Supports a minimala version of RVFI 
\item Built into the core-v-verif
\item Already modified to work with DPI functions from systemverilog
\end{itemize}
& \begin{itemize}
\item Modified for the CVA6 Core
\item Currently in active development, so interfaces and functionality can change in the future
\item Not available in the same core-v-verif branch used by the CV32E40S/X cores which can get ugly.
\end{itemize} \\
\hline
\end{tabularx}
\end{table}







%\section{Memory regions}
%
%Spike needs to be configured to use the same memory regions as the test binaries.
%
%The binaries are generated using \lstinline{link.ld}
%
%This linkscript sets ram from \lstinline{0x00000000}
%
%by changing this to something else spike no longer complains, but the configuration of the processor changes.
%
%
%Spike configures a debug module from 0x0 to 0x1000 and a reset vector from 0x1000 to 0x2000 (REF mail. Sjekk opp). This overlaps with the memory description from link.ld and needs to be removed.
%
%
%One fix in link.ld:
%move ram to 0x80000000 and \lstinline{boot_address = 0x80000080}.
%set \lstinline{boot_addr_i = 0x80000080}.
%This kind of works, but we should modify spike instead of link.ld.




%\section{Experiment}
%
%\subsection{pure spike with cv32e40s test}
%memory 0x0 invalid
%
%\subsection{CVA6 test elf on pure spike}
%works
%
%\subsection{cva6 spike with cv32e40s test}
%memory 0x0 invalid
%
%
%\subsection{Move ram in link.ld to another location}
%Spike runs but core testbench fails




\subsection{Using CVA6 spike}

We choose to go with CVA6 spike implementation, but this also requires some modifications to be compatible with CV32E40S, and is one of the contributions of this thesis.

%Some modifications to CVA6 spike are necessary
%\begin{itemize}
%    \item Change memory mapping to handle cv32e40s binaries 
%    \item \lstinline{CV_VP_REGISTERs} are from \lstinline{0x00800000} and contain registers like virtual printer used by stdout and other thing.
%    \item  disable dtb to disable the spike bootloader that overlaps with core-v memory regions
%    \item Modify CSR registers
%\end{itemize}



\section{Making the ISS replaceable : ISS Requirement \ref{issReq:replacable} }

\subsubsection{ISS interface}

To easily interface with the ISS the communication is done in \file{iss_wrap_pkg.sv}. This exports the generic functions \lstinline{iss_init(...)} and \lstinline{iss_step(...)}) that "easily" allows the ISS the be replaced in the future by only modifying \lstinline{iss_wrap_pkg.sv}. The \lstinline{iss_init(...)} configures Spike with the correct ISA string, sets the boot address, sets the correct parameters and loads the ELF binary. 

\lstinline{iss_step(...}) steps spike one instruction and returns an \lstinline{st_rvfi} rvfi struct.

\tmp{More on the interface}

\section{Matching the ISS to the core: ISS Requirement \ref{issReq:csr} \& \ref{issReq:binaries}}

\subsection{Parameters}

The core-v-verif Spike version has implemented passing of parameters to Spike, and exports functions like \ccode{spike_set_param_str(base,string,value)}, and \ccode{spike_set_param_uint64_t(base,string,value)}\cite{openhwgroupOpenhwgroupCorevverif2023}. It also exports \ccode{spike_set_default_params(profile)}, that allows spike to be configured to different processors. 

We can call these function from \ccode{iss_init(...)} to configure the necessary modifications required to match the core. The necessary modifications will be discussed below. 

\subsection{Mismatched CSRs}

There are some differences in the implementation of the CSRs from the core and Spike. This happens because the RISC-V specification is not always fully accurate, and provides some optional implementations of some CSRs \cite{watermanRISCVInstructionSet2021} and some CSRs are specific to a core. Some necessary modifications are described below.

\begin{itemize}
    \item \rv{mvendorid}  - This is specific to the vendor and should be reset to the OpenHW vendor ID (\lstinline{0x602}) 
    \item \rv{marchid} - This is unique to each microarchitecture from a vendor. It should be reset to CV32E40S marchid (\lstinline{0x15})
    \item \rv{misa} - Spike does not have bit 23 set, which should be set if non-standard extensions are present\cite{watermanRISCVInstructionSet2021}. The CV32E40S hard-wires this to 1. We can add the "xdummy" to the ISA string passes to spike, so spike sets bit 23 high.
    \item \rv{mcountinhibit} - This should be reset to 5 instead of 0
    \item \rv{mcycle, mcycleh} - Disabeling of mcycle was not implemented in Spike. This required a modification to Spikes functionality to take mcountinhibit into account and only increase \rv{mcycle} if it is enabled.
\end{itemize}

%Mstatus differs this is from \cite{watermanRISCVInstructionSet2021}:
%M-mode software can determine whether a privilege mode is implemented by writing that mode
%to MPP then reading it back.
%If the machine provides only U and M modes, then only a single hardware storage bit is
%required to represent either 00 or 11 in MPP.


\subsection{Memory Mapping}

In order to run the same binaries as the core and fulfill \Cref{issReq:binaries}, Spike must be modified with the same memory mapping as the core.


%\url{https://github.com/openhwgroup/core-v-verif/tree/master/cv32e40s/bsp}
The binaries used in core-v-verif is built using the \acrfull{bsp} provided with core-v-verif in \dir{cv32e40s/bsp}. Among other things, this contains a linker script (\file{link.ld}) that defines the memory layout of the program, specifying the placement of code and data in memory \cite{openhwgroupCorevverifCv32e40sBsp}. 

The core-v-verif linker script has two sections, \lstinline{ram} and \lstinline{dbg}. The ram starts at address \lstinline{0x0} and has a size of \lstinline{0x400000} (4MB). The debug section starts at \lstinline{0x1A110800} and has a size of \lstinline{0x1000}. Additionally, the core has memory regions for virtual periphery registers and \lstinline{0x00800000}.

%To make Spike work with this new memory mapping we have to do the following:
%
%\begin{enumerate}
%    \item Remove spikes default memory mapping which overlaps with our new memory mapping.
%    \item Configure spike with the new memory mapping
%    \item Make spike start execution at the start address of \file{link.ld}.
%\end{enumerate}


Spike always starts running at the \lstinline{DEFAULT_RSTVEC = 0x1000}. Spike places a custom boot rom at this reset location \cite{evancoxAddDocumentationLowlevel2017}.
After this is run, spike will jump to the provided program counter or to the \lstinline{_start} symbol from the ELF file. Aditionally, spike has a debug module in memory.

These memory regions overlap with the \lstinline{ram} region from \file{link.ld}.
To avoid conflicts, the reset vector and debug module from Spike must be disabled. Spike's default boot loader can be disabled by setting \lstinline{dtb_enabled = false}, and the debug module can be removed from the \ccode{sim_t} class.


To run the core-v-verif binaries, spike must be configured with 3 memory regions discussed earlier. Ram from \lstinline{0x00000000} with size \lstinline{0x400000}, Debug from \lstinline{0x1a110800} with size \lstinline{0x1000}, and corev virtual registers from \lstinline{0x00800000} with size \lstinline{0x1000}. The corev virtual registers contain registers used for example to write to stdout, and to inject interrupt etc.

These modifications allow an elf file generated with core-v-verif to run successfully in spike.


%\subsection{Volatile CSRs}
%
%\tmp{ImperasDV and RVVI supports volatile CSRs and memory regions. This could avoid fine tuning all CSRs to fit the core, but increases reliance on the core and gives verification gaps.}

\section{Step through individual instructions: ISS Requirement \ref{issReq:step} \& \ref{issReq:state}}


Normally, Spike runs from the main function in \file{spike.cc}, and runs sequentially from start to finish using the \ccode{sim_t::run()} function.

To use Spike in the reference model, we need a way to interface with it that runs only one instruction and returns the state changes from this instruction. This requires some modification. 

We want to use DPI functions to interface with Spike from the reference model. To do this, we need to instantiate Spike in a DPI wrapper instead of running it from the main function. We want an initialization function that instantiates and configures Spike, a step function to step through one instruction and return the state changes as an RVFI output, and functions to inject asynchronous events into Spike.

The Spike implementation in core-v-verif has been modified to support single-stepping instructions by exporting a set of DPI functions in \file{riscv_dpi.cc}. Spike is expanded with two new classes \ccode{Processor}, and \ccode{Simulation}, that inherit from \ccode{processor_t} and \ccode{sim_t} to get access to and build upon the processor state and simulation details.

The most important addition is the \ccode{Processor::step()} method. This steps Spike one instruction and fills the \ccode{st_rvfi} RVFI struct that is sent out of spike over DPI to the reference model. The RVFI struct is filled using the values from the \ccode{state_t} state struct and the \ccode{Processor} class.



\subsection{Return RVFI after instruction}

To properly support \Cref{issReq:state} and output RVFI after each instruction, some modifications must be made. The currently supported RVFI output added to Spike in core-v-verif is minimal and does not always match the RVFI output from the core.



\subsection{RVFI problems}
RVFI from CVA6 is sometimes off. RVFI signals are generated by calling \lstinline{insn.rs1()} which selects the correct number of bits from the insn. This is a problem when the RISC-V format does not include this field. For example the insn \lstinline{addi x3, x3, 1224} is an I-type instruction, with only rs1 and rd registers, and not rs2. When RVFI items are generated and \lstinline{insn. rs2()} is called, it does not consider the instruction type and incorrectly stores the rs2 bits that in the case of an I-type overlap with the Imm bits, leading to an incorrect rs2 rvfi item.


\subsection{Adding the memory section to rvfi}

Core-v-verif Spike does not support memory output over RVFI, so we will add this support. 
CV32E40S has expanded RVFI to support multiple memory operations per instruction \cite{openhwgroupRISCVFormalInterface2023}. Since all RV32I instructions support single-memory operations, we will implement this first.

For logging, spike stores all register and memory commits during an instruction. This can be used to generate the \rv{rd} and memory RVFI signals. Register commits are stored in the unordered map \ccode{log_reg_write} with register number and data, while memory read and write commits are stored in the vectors \ccode{log_mem_read} and \ccode{log_mem_write} containing tuples address, value, and size.

We use the values stored in these \textit{commit logs} to generate the RVFI outputs. The details can be found in \ref{}

\subsection{RVFI interrupts and traps}

Some modifications are also required for the interrupt signals in RVFI.

In Spike, interrupts and synchronous traps are both reported using the \ccode{which_trap} variable, but interrupts are marked with the MSB high.

For exceptions (traps), the \lstinline{rvfi_trap} signal is asserted the instruction the trap occurs, while \lstinline{rvfi_intr} is asserted on the next instruction, which is the first instruction of the trap handler. To delay the interrupt RVFI output one step, we store the interrupt output into \ccode{next_rvfi_intr}, which is output to \ccode{rvfi_intr} at the next instruction.


%For interrupts, we should only output \lstinline{rvfi_intr} and not \lstinline{rvfi_trap}. When taking an interrupt, Spike must call the step function two times, one time to take the interrupt, and the second to actually execute the first instruction of the interrupt handler. In spike, the information about the interrupt is generated during the first step and \lstinline{taken_trap} stores if an interrupt or trap happens, and \lstinline{which_trap} holds the cause of the trap/interrupt. Aditionally the MSB of signals wether the trap is for an exception or interrupt. Since we only collect the rvfi data from the second step when taking interrupts, we generate the \lstinline{rvfi_intr} signals in the first step when the trap data is available, and store this to \lstinline{next_rvfi_intr}, which is output to \lstinline{rvfi_intr} at the next step, along with the interrupt handler.

\subsection{Debug}

Similarly to interrupts, a delay must also be added to debug mode caused by \rv{ebreak}. This should report a trap on the instruction \rv{ebreak} is executed and output to \sv{rvfi_dbg} when at the next instruction when debug mode is active.

\rv{rvfi_dbg_mode} should be high for all instructions run in debug mode. We can use the \ccode{debug_mode} stored in the \ccode{state_t} to generate this but also delay this one instruction by reading from the previous state to only output it when the whole instruction ran in debug mode, and not when an instruction enabled debug mode.

\subsection{CSR}

To support \Cref{issReq:CSR_out}, we also want to output CSR changes over RVFI. This is currently also implemented in the core-v-verif Spike version.

\section{Interrupt injection: ISS Requirement \ref{issReq:interrupt}, \ref{issReq:set_CSR}, and \ref{issReq:interruptEnabled}}
\label{sec:iss_interruptInjection}

We add a new DPI function called \ccode{iss_intr()} to inject interrupts. This calls the \ccode{Processor:interrupt(...)} method via \ccode{Simulator::interrupt(...)}, and is shown in \Cref{lst:interrupt}. This function is called every clock cycle to determine if something has changed, and an interrupt can be taken. We set the \rv{mip} CSR even though the interrupt is not enabled to avoid a mismatch with the core if the \rv{mip} CSR is read.

To support \Cref{issReq:set_CSR}, we also want to consider the values of the external CSR explained in \Cref{sec:ps_side-effects}. To do this, we take \ccode{mie} and \ccode{interrupt_allowed} as inputs to the function. \ccode{mie} is set at line \ref{line:mie}, overwriting the current \rv{mie} when determining if the interrupt can be taken. \ccode{interrupt_allowed} is set at line \ref{line:interrupt_allowed}. This variable in the \ccode{processor_t} class is checked before taking an interrupt when Spike steps and will be discussed later.

To support \Cref{issReq:revertState}, we also take the number of steps to revert during an interrupt as an input. As discussed in \Cref{sec:ps_revertion}, we want to revert the state only if the interrupt will be taken, and before setting the \rv{mip} bits, so we call \ccode{revert_step(revert_steps)} in line \ref{line:revert}.

When Spike takes an interrupt, the step is used to change the state of the processor, storing the previous PC to \rv{mepc} and changing the PC to the correct interrupt handler, but it does not actually execute the instruction at the new PC. For an interrupt to be taken and the first instruction of the interrupt handler to be run, we must step Spike two times. 

Since we export separate interrupt and step functions, we choose to step once in the interrupt function, but only if we know the interrupt will be taken. This ensures that the next time the step function is run, it will actually execute an instruction instead of only taking the interrupt. 

\begin{sloppypar}
To only step if the interrupt will be taken, we also define a \ccode{will_trigger_interrupt(mip)} method that determines if the interrupt will be taken based on the current debug mode, if the interrupts are enabled in \rv{mstatus}, and if the set \rv{mip} bits are enabled in \rv{mie}. To support \Cref{issReq:set_CSR}, we also consider the \ccode{interrupt_allowed} input in addition to \ccode{will_trigger_interrupt(mip)} .
\end{sloppypar}

\begin{clisting}[label=lst:interrupt, caption=The function used to apply interrupt in spike.,escapechar=|]
bool Processor::interrupt(reg_t mip, reg_t mie, uint32_t revert_steps, bool interrupt_allowed) {
  this->interrupt_allowed = interrupt_allowed; |\label{line:interrupt_allowed}|
  state->mie->write_with_mask(IRQ_MASK, mie); |\label{line:mie}|
  if(interrupt_allowed && will_trigger_interrupt(mip)) {
    this->revert_step(revert_steps); |\label{line:revert}|
    state->mip->write_with_mask(IRQ_MASK, mip);
    this->step(1, vref); |\label{line:step}|
    return true;
  } else {
    state->mip->write_with_mask(mask, mip);
    return false;
  }
} 
\end{clisting}

\section{Modifications to interrupt taking: ISS Requirement \ref{issReq:interruptEnabled} \& \ref{issReq:interruptOrdering}}
\label{sec:iss_interruptModifications}

\subsection{Interrupt allowed}

To support \Cref{issReq:interruptEnabled}, we add a separate \ccode{interrupt_allowed} variable to the \ccode{processor_t} class that is checked before taking an interrupt. 

\subsubsection{External interrupts}

The CV32E40S core only has some of the interrupt pins enabled, and some pulled to 0\cite{openhwgroupExceptionsInterruptsCOREV2023}. For the standard interrupts in bit \texttt{15-0} in \rv{mip}, these are specified in the RISC-V specification \cite{watermanRISCVInstructionSet2021} and will be set correctly in Spike if it is configured with the correct privilege levels.
The problem is with the external interrupts in bit \texttt{31-16} of \rv{mip}, which are not enabled in Spike. We must modify the write mask used when Spike writes to \rv{mie} to enable the custom interrupts by setting bit \texttt{31-16} high.

\subsection{Interrupt Ordering}

The RISC-V specification specifies the priority order of the standard interrupt bits (bit \texttt{0-15}) in \rv{mip} but does not specify a priority order for the custom external interrupts in bit \texttt{31-16} \cite{watermanRISCVInstructionSet2021}, as these can be platform specific. In CV32E40S, the external interrupt with the highest ID will get the highest priority \cite{openhwgroupExceptionsInterruptsCOREV2023}.

To make the interrupt priorities the same in the core and Spike can modify the functionality of the \ccode{processor_t::take_interrupt()} method to correctly order the external interrupts. This approach assumes that the interrupt ordering for the external interrupts will be the same for all cores. This might not necessarily be the case since the ordering is not defined in the specification \cite{watermanRISCVInstructionSet2021}. Future work should, therefore, make the ordering of external interrupts configurable or move the interrupt-taking functionality of Spike to a separate, core-specific module.

\section{Revert state: ISS Requirement \ref{issReq:revertState}}
\label{sec:iss_revert}

\Cref{issReq:revertState} specifies that we must be able to revert Spike to a previous state to discard instructions that are flushed from the pipeline shell, as discussed in \Cref{sec:ps_revertion}. THis involves restoring register file values, \acrshort{csr}s, memory contents, \acrshort{pc}, and other relevant state information. 

We never have to store more states than the number of stages in the pipeline, because revertion is only done to discard instructions flushed from the pipeline. This allows a fixed-size array to be used with the same size as the number of pipeline stages. If a synthesizable ISS is used in the future, using a fixed-size array would also make these modifications synthesizable, meeting \Cref{issReq:formal}.

Most of this state data is encapsulated in Spikes \ccode{state_t} struct. A straightforward approach is to store a snapshot of this struct before executing each instruction. When a flush occurs, we can restore a previous state by replacing the current state with a previous snapshot state. 

Using \ccode{sizeof(state_t)}, we find that the struct size is 3592 bytes. While storage constraints are not a primary concern, future work could be to store only the relevant data to a smaller struct, but we can live with the size of \ccode{state_t} for now. 

Memory writes during an instruction gets more complicated, as these are not stored in the \ccode{state_t} struct. There are several possible approaches:

\begin{enumerate}
    \item \textbf{Full memory snapshots}: We could store a complete memory copy before each instruction. Spike uses a \ccode{sparse_memory_map} to store locations of different memory pages \cite{SpikeRISCVISA2023}. To copy the whole memory we would have to make a copy of each page pointed to by the memory map. Additionally, the cache and TLB also has to be properly updated. This is highly impractical due to the potentially large size of the memory and uneccesary complexity.
    \item \textbf{Cache snapshots}: An alternative solution is to store a snapshot of the cache. The cache is smaller than the whole memory, but restoring it might not be as straightforward since memory writes can bypass the cache and store it straight to memory \cite{hennessyComputerArchitectureQuantitative2019}.
    \item \textbf{Storing pre-write values}: One approach is to store the original values at memory locations before these are written to. On reversion, we can store back all of the original values. This approach is drastically smaller than the previous approaches, and we do not have to consider the cache or TLB\tmp{Justify}.
\end{enumerate}


\subsubsection{Storing the changes to memory for every instruction. (or values before memory operation)}
We choose to store the values before a write is done to the address.
When the pipeline is flushed, each of these memory operations has to be reverted back to its original state. This allows us to use the top level \ccode{store()} function in Spike to revert each memory operation. This would automatically handle the TLB, caches, and storing to the correct memory address on the correct page.

The \ccode{state_t} already contais commit logs holding reads and writes to registers and memory, used to make the execution log from spike. The memory logs hold address, value, and size in a vector of tuples like \ccode{typedef std::vector<std::tuple<reg_t, uint64_t, uint8_t>> commit_log_mem_t;}. The commit log is written to in \ccode{store()} in \file{mmu.h}. We are interested in the value before writing, and not the value stored in the commit log, which is the value after writing. 

We can therefore expand the \ccode{state_t} to hold another commit log of values before writing, called \ccode{log_mem_pre_write}. This vector holds the address, value, and size of memory operations. We can expand the \ccode{store()} function in \file{mmu.h} read the value of the given address before writing to it, and storing this value and the address to \ccode{log_mem_pre_write}.

%To load the memory values before writing to them, we can either use the \ccode{load()} function from inside \ccode{store()} or directly use the relevant lines from \ccode{load()} in \ccode{store()}. If we were to call the \ccode{load()} function, this would also store to the \ccode{log_mem_read} commit log, which would affect the generated RVFI output and spike execution log. We would therefore have to clear the \ccode{log_mem_read} after running \ccode{load()} or disable the commit log before running it.

Since the address generation from \ccode{load()} and \ccode{store()} are similar, we can easily add the relevant lines of code from \ccode{load()} to \ccode{store()}. The expanded \ccode{store()} from \file{mmu.h} is shown in \Cref{lst:store} with the added lines marked with \ccode{+}.


\begin{clisting}[caption={Modified \ccode{store()} function from \file{mmu.h} with new lines marked with \ccode{+}.}, label={lst:store}]
  template<typename T>
  void ALWAYS_INLINE store(reg_t addr, T val, uint32_t xlate_flags = 0) {
    reg_t vpn = addr >> PGSHIFT;
    bool aligned = (addr & (sizeof(T) - 1)) == 0;
    bool tlb_hit = tlb_store_tag[vpn % TLB_ENTRIES] == vpn;
    target_endian<T> previous_value;


    if (xlate_flags == 0 && likely(aligned && tlb_hit)) {
+     //Store previous value before writing
+     previous_value = *(target_endian<T>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr);

      *(target_endian<T>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val);
    } else {
+     //Store previous value before writing
+     load_slow_path(addr, sizeof(T), (uint8_t*)&previous_value, xlate_flags);

      target_endian<T> target_val = to_target(val);
      store_slow_path(addr, sizeof(T), (const uint8_t*)&target_val, xlate_flags, true, false);
    }

    if (unlikely(proc && proc->get_log_commits_enabled())) {
      proc->state.log_mem_write.push_back(std::make_tuple(addr, val, sizeof(T)));
+     proc->state.log_mem_pre_write.push_back(std::make_tuple(addr, from_target(previous_value), sizeof(T)));
    }
  }
\end{clisting}

\subsubsection{Storing states for instructions}

Since we store the \ccode{log_mem_pre_write} in the \ccode{state_t} it should be sufficient to only store this state struct for each instruction in the pipeline to store the registers, \acrshort{csr}s, and memory operation for each instruction. 

To avoid converting this struct to SystemVerilog and back to \cpp, it is easier to store this state \textit{snapsh} in Spike and use a DPI function call from the pipeline shell to signal which snapshot to revert back to.

Because we only need the states for the instructions that are currently in the pipeline, we only need to store a set number of previous states. If we in the future want to use a synthesizable ISS, this method can be advantageous as fixed size array is easier to synthesize than a dynamic array.

In Spike, we can store the previous states in a \ccode{deque} double-ended queue. This makes it easy to insert the most recent state at the beginning of the queue and remove the oldest state from the end of the queue when the instruction leaves the pipeline. 
We can also easily access items at a specific index to revert the state to a given previous state.

We store the previous states in the \ccode{Processor} class. We store the previous state at the beginning of the \ccode{step()} function. After executing the instruction, we store the \ccode{llog_mem_pre_write} vector into a \ccode{prev_changes_t} struct along with the previous state. This is stored in the \ccode{previous_states} \ccode{deque}.



\subsection{Reverting state}

We add the \ccode{Processor::revert_step(int num_steps)} method to revert the state.
To revert the state, we override the current state with the state stored at the index of \ccode{num_steps} in \ccode{prev_changes}. To revert the memory operations, we then iterate over all the previous states and the content of \ccode{log_mem_pre_write}. For all the stored memory writes, we call the \ccode{store()} method with the stored address, value, and size of each memory write.

To get the order of operations right, the \ccode{revert_step()} method is called inside the \ccode{interrupt()} and \ccode{debug()} methods, as explained in \Cref{sec:ps_revertion} and \Cref{sec:iss_interruptInjection}.

\subsection{The problem with revertions}
\tmp{PGK: Bør dette diskuteres her eller i discussion?}

This solution, storing the states inside Spike, has some problems and disadvantages.

CSRs are written with \ccode{processor_t::put_csr(int which, reg_t val)}. This writes to the CSR stored in \ccode{state.csrmap} as a \ccode{shared_ptr}. This means that when we copy the state struct into the deque, we only copy the pointer, not the actual CSR value. We must either deep copy all the CSR values in \ccode{csrmap}, storing new values for the pointers. We can also implement a solution similar to memory writes, where we iterate over previous CSR writes and revert them. One last solution is to use the external CSR in the pipeline shell. Since we already export CSR writes over RVFI (\Cref{issReq:CSR_out}) and update the external CSR (\Cref{sec:ps_side-effects}), it is possible to update the internal Spike CSR to match the external CSR when reverting the state. When these CSRs are updated in the external CSR, they would no longer have to be flushed since it mimics the actual CSR in the core.

\tmp{This could maybe be done for the state aswell}

%\section{Custom instructions:\Cref{issReq:custom}}
%
%\tmp{ZCMP supports multiple memory operations per instruction. This affects RVFI}
%
%\tmp{Also supports multiple RD writes, which must also be handled with RVFI}

%\section{Update: \Cref{issReq:update}}


\section{WFI}
\label{sec:wfi}

\tmp{Flytt til ch 5?}

A \rv{wfi} instruction should halt execution until an interrupt occurs. This requires some modifications to the design to function correctly.


One problem with \rv{wfi} instructions and the pipeline shell is that the next steps in Spike will not be executed when a \rv{wfi} is set. This prohibits the pipeline from filling up with the upcoming instructions. When an interrupt is taken, and \rv{wfi} is awakened, the next instructions are not loaded into the pipeline, causing a mismatch. To avoid this, we fully disable \rv{wfi} in Spike and let the pipeline shell handle the waiting caused by a \rv{wfi}. This is legal since the RISC-V specification also specifies that implementing \rv{wfi} as a \rv{nop} is a legal implementation \cite{watermanRISCVInstructionSet2021}. As will be discussed in \Cref{sec:res_tests}, this causes some problems when a \rv{wfi} is the last instruction of a program.

%%A \rv{wfi} should as wake up to an interrupt even though \rv{mstatus.mie} is disabled \cite{watermanRISCVInstructionSet2021}. 
%%The added \ccode{interrupt_allowed} bool added to Spike should not stop a \rv{wfi}we added should not block \ccode{take_interrupt(pending_interrupt)} from running even if interrupts are not allowed, since this could lead to a \rv{wfi} not waking up when an interrupt is passed to spike.


%To allow the pipeline to fill up with the upcoming instructions after the \rv{wfi}, we can disable wfi in Spike by setting \ccode{in_wfi = false} in the step function in \file{Proc.cc}. This way, the next instruction will run on the next step, and we will have to make sure \rv{wfi} waits operate as intended outside of Spike in the reference model. When using the retirement dependent approach, the \rv{wfi} instruction will automatically wait to be run until the core runs, but we need some way to determine that an interrupt actually occurred, causing the execution to continue after the \rv{wfi}. \tmp{TODO: this}

\section{Debug requests}


To insert asynchronous interrupts into Spike, we define a new DPI function \ccode{iss_set_debug(...)} that calls the method \ccode{Processor::set_debug(bool debug_req, uint32_t revert_steps, bool debug_allowed}. It takes in the debug request, the number of revert steps, and the \ccode{debug_allowed} as parameters, similarly to \ccode{iss_intr(...)}. 

If Spike is not in debug mode, a new debug request is made, and debug is allowed, we set the \ccode{processor_t::halt_request} variable to \ccode{HR_REGULAR}. At the next step, Spike will enter debug mode, store the cause and privilege to \rv{dcsr}, store the PC to \rv{dpc}, and change the PC to the address specified in \tmp{TODO}. 


One timing difference between interrupts and debug requests in the CV32E40S core is that when an interrupt is taken, the pipeline is immediately flushed, and the PC changed to the interrupt handler, while when an async debug is taken, the pipeline is first halted one cycle, before flushing all or parts of the pipeline the next cycle. The WB stage is not flushed if the interrupt is caused by \rv{EBREAK} or \rv{TRIGGER}


\subsection{RVFI}
\tmp{i rvfi?}

RVFI support also has to be added for debug. All instruction run in debug mode should output \ccode{rvfi_dbg_mode = 1}, and the first debug instruction should output the debug cause in \ccode{rvfi_dbg} \cite{openhwgroupRISCVFormalInterface2023}.


\subsection{\rv{dcsr}}
\tmp{Unødvendig?}

The \rv{dcsr} debug control and status CSR differs between the core and spike. The core has the \rv{MPRVEN} and \rv{STOPCYCLE} fields hardwired to 1, while these are hardwired to 0 in Spike. Both these fields are specified as optional in the RISC-V Debug Specification \cite{pauldonahueRISCVDebugSupport2023}, so these field should be configurable in spike to match different cores.


\subsection{EBREAK in pipeline when external debug request is enabled}
\tmp{I PS?}

Since the ISS is run in IF, when an \rv{ebreak} instructions runs in IF, the ISS sets debug mode to 1. This causes problems for a debug request asserted while the \rv{ebreak} is in the pipeline, but not yet executed in WB. Since the ISS already is in debug mode caused by the \rv{ebreak}, the debug request would not be taken, and the cause of the debug mode would be the \rv{ebreak} instead of the external debug request, which has a higher priority. To fix this, we can modify \ccode{set_debug()} to check if a new debug request is made while the debug mode is not set in the pipelines shell but is set in the ISS, and the current debug cause is by an \rv{ebreak}. This only occurs if the \rv{ebreak} is still in the pipeline. If this is the case, we can disable debug mode, so that the external debug request can trigger debug mode again with the correct cause.


