\chapter{Instruction Set Simulator}


\section{Choosing ISS}

\tmp{TODO: Lim inn/referer til diskusjon om ISS valg fra prosjektoppgave}


There are multiple versions of spike tailored to different cores. One potential version of spike to use is the version modified to use in tandem verification with the CVA6 core from the openHW group. This version of Spike is modified to serve as a reference model for CVA6 which also utilizes the core-v-verif verification environment. This Spike implementation is still in active development but adds some features that are advantageous for integrating into the reference model.

CVA6 features:

The ISS can no longer just run in main but needs to stay consistent between DPI function calls. The CVA6 implementation does this by using a file \lstinline{riscv_dpi.cc} that has DPI functions for setting parameters, initializing spike, and stepping through the model. To maintain the state, this file has several classes instanciated as global variables, the most important being \lstinline{Simulation* sim} which is an addition made with the CVA6 spike implementation. The \lstinline{Simulation} class inherits from the spike \lstinline{sim_t} class and adds a lot of the functionality implemented in the main function in pure Spike.  



\begin{table}[!htb]
\centering
%\setlist[itemize]{font= \color{DeepSkyBlue}, wide, leftmargin=*, noitemsep, after=\vspace*{-\topsep}}
%\setlength{\extrarowheight}{3pt}
%\setlength{\tabcolsep}{3pt}
\caption{Summary of advantages and disadvantages of Plain Spike and CVA6 Spike}
\label{tab:spikevsail}
%\begin{tabularx}{\textwidth}{|p{15mm}|*{2}{>{\compress\RaggedRight\arraybackslash} X |}}
\begin{tabularx}{\textwidth}{|p{15mm}|*{2}{>{\arraybackslash} X |}}
\hline
ISS & Advantages & Disadvantages \\
\hline
Plain Spike
& \begin{itemize}
\item Widely used and tested 
\item Stable 
\item Easier to keep up to date with changes to Spike
\end{itemize}
& \begin{itemize}
\item No support for RVFI outputs
\item Interrupt and debug injection must be added
\item DPI support must be added
\end{itemize} \\
\hline
CVA6 Spike
& \begin{itemize}
\item Supports a minimala version of RVFI 
\item Built into the core-v-verif
\item Already modified to work with DPI functions from systemverilog
\end{itemize}
& \begin{itemize}
\item Modified for the CVA6 Core
\item Currently in active development, so interfaces and functionality can change in the future
\item Not available in the same core-v-verif branch used by the CV32E40S/X cores which can get ugly.
\end{itemize} \\
\hline
\end{tabularx}
\end{table}







%\section{Memory regions}
%
%Spike needs to be configured to use the same memory regions as the test binaries.
%
%The binaries are generated using \lstinline{link.ld}
%
%This linkscript sets ram from \lstinline{0x00000000}
%
%by changing this to something else spike no longer complains, but the configuration of the processor changes.
%
%
%Spike configures a debug module from 0x0 to 0x1000 and a reset vector from 0x1000 to 0x2000 (REF mail. Sjekk opp). This overlaps with the memory description from link.ld and needs to be removed.
%
%
%One fix in link.ld:
%move ram to 0x80000000 and \lstinline{boot_address = 0x80000080}.
%set \lstinline{boot_addr_i = 0x80000080}.
%This kind of works, but we should modify spike instead of link.ld.




%\section{Experiment}
%
%\subsection{pure spike with cv32e40s test}
%memory 0x0 invalid
%
%\subsection{CVA6 test elf on pure spike}
%works
%
%\subsection{cva6 spike with cv32e40s test}
%memory 0x0 invalid
%
%
%\subsection{Move ram in link.ld to another location}
%Spike runs but core testbench fails




\subsection{Using CVA6 spike}

As explained in \ref{} the CVA6 spike implementation has many advantages to our usecase, so we want to use this implementation.

Some modifications to CVA6 spike are necessary
\begin{itemize}
    \item CVA6 Spike relies on files from verilator \lstinline{svdpi.h, vpi_user.h} used to link spike and systemverilog over DPI. These files needs to be available to compile spike.
    \item Change memory mapping to handle cv32e40s binaries 
    \item \lstinline{CV_VP_REGISTERs} are from \lstinline{0x00800000} and contain registers like virtual printer used by stdout and other thing.
    \item  disable dtb to disable the spike bootloader that overlaps with core-v memory regions
    \item Modify CSR registers
\end{itemize}


\section{Requirements}

Functional requirements. 

\begin{enumerate}

%\item \textbf{Provide visibility into multiple instructions} \label{req:visibility}
%
%\par To simulate the pipeline, we need to track multiple instructions simultaneously, corresponding to the instructions in the different pipeline stages. This requires that we can "see" the $n$ coming instructions according to the pipeline stages, or allow separation of fetching, decoding, execution, etc into separate cycles. 

\item \textbf{Modify ISS to match the core.} \label[req]{req:csr}

\item[]  The ISS should be able to modified to match the core. Specifically regarding memory mapping and CSRs.

\item \textbf{Run \acrshort{riscv} binaries generated from core-v-verif.} \label[req]{req:binaries}

\item[]  The ISS must be able to run the same binaries as the core.

\item \textbf{Support stepping through the execution at the Instruction Level} \label[req]{req:step}

\item[]  Since the reference model runs in lock-step with the DUT, we need to be able to step through the instructions at the instruction level, and be able to only run one instruction at a time, before waiting to step into the next instruction.

\item \textbf{Provide processor state after each instruction} \label[req]{req:state}

\par The ISS needs to output the state changes executed after each instruction so that the pipeline shell can apply these changes in a cycle-accurate manner. 
%To be able to use the ISS in verification, we need to access the processor state changes after each instruction to compare with the DUT. This should preferably be in the RVFI format or enough information should be available to convert into an RVFI item.

\item \textbf{Revert the state of the ISS n number of instructions} \label[req]{req:revertState}

\par As discussed in \cref{sec:app3}, if we run the ISS before the pipeline simulation, we need to be able to revert the ISS state to a previous state to simulate pipeline flushing.

%\item \textbf{Support modification of instructions} \label[req]{req:modification}
%
%\par To simulate interrupts in the pipeline, it might be necessary to simulate pipeline flushing and halting. To do this we should be able to modify the instructions in the pipeline e.g. to replace them with empty NOP operations to flush the pipeline or halt execution of an instruction. 

\item \textbf{Enable external injection of interrupts} \label[req]{req:interrupt} 

\par External interrupts and debug requests are inserted into the reference model independently of the ISS. To simulate the interrupts, we must be able to tell the ISS to take an interrupt by jumping to the trap handler's PC and correctly executing the side effects at the correct cycle. 

\item \textbf{Support addition of custom extensions and instructions} \label[req]{req:custom}

\par A large driving force for using RISC-V is the ability to add custom extensions. Therefore, custom instructions and extensions must be easily created and added to the ISS without modifying large parts of the model.

\item \textbf{Ensure maintainability while meeting requirements} \label[req]{req:update}

\par The ISS should be easily maintained and updated while still meeting the requirements. Modifications to the ISS should be kept to a minimum and be done in a way that allows the ISS to be easily updated.

\item \textbf{Actively maintained and thoroughly tested} \label[req]{req:maintained}

\par The ISS should be mature and thoroughly tested. It should be actively maintained and likely to be updated in the future.

\item \textbf{The ISS should be easily replaceable in the future.} \label[req]{req:replacable}

\par The ISS should be mature and thoroughly tested. It should be actively maintained and likely to be updated in the future.



%\item \textbf{Load the same instructions as the DUT} \label[req]{req:DUTins}

%\par The ISS should be able to load the same instructions as the DUT.

%\par As discussed in \cref{sec:shell_iss_interaction}, to be able to model the reference model around an ISS, it is helpful to be able to separate the register file from the rest of the ISS, or be able to have a copy of the register file, and update the register file inside the ISS when necessary.

\end{enumerate}

\section{Making the ISS replaceable : \Cref{req:replacable} }

\subsubsection{ISS interface}

To easily interface with the ISS the communication is done in \file{iss_wrap_pkg.sv}. This exports the generic functions \lstinline{iss_init()} and \lstinline{iss_step(rvfi}) that "easily" allows the ISS the be replaced in the future by only modifying \lstinline{iss_wrap_pkg.sv}. The \lstinline{iss_init()} configures Spike with the correct ISA string, sets the boot address, sets the correct parameters and loads the ELF binary. 

\lstinline{iss_step(ref st_rvfi s_reference_model}) steps spike one instruction and returns an \lstinline{st_rvfi} rvfi struct.

\textbf{Design choice:} return \sv{st_rvfi} or pass by reference into \sv{iss_step()}?

We can't pass a part of a struct by reference, so returning makes more sense.
Returning the struct makes it clearer what happens and can be used like below

\begin{systemverilog}
always_ff @(posedge clk) begin
    if(step) begin
        if_id_pipe_o.rvfi = iss_step();
        if_id_pipe_o.valid = 1'b1;
    end
    else begin
        if_id_pipe_o.rvfi = if_id_pipe_o.rvfi;
        if_id_pipe_o.valid = if_id_pipe_o.valid;
    end
end

\end{systemverilog}

\tmp{More on the interface}

\section{Same CSRs: \Cref{req:csr}}

\subsection{Mismatched CSRs}

There are some differences in the implementation of the CSRs from the core and Spike. These are listed below.

\begin{itemize}
    \item marchid - reset to CV32E40S marchid (\lstinline{0x15})
    \item misa - \textbf{temporary} set to \lstinline{0x40901104} to match isa. 
    \item mvendorid  - reset to \lstinline{0x602} (OpenHW mvendorid)
    \item mcountinhibit - reset to 5 instead of 0
    \item mcycle, mcycleh - Counted when they should not count. modified Spike functionality to take mcountinhibit into account
\end{itemize}

csr\_instructions fail because MPP is 11 for core and 00 for spike. 

this is from \cite{watermanRISCVInstructionSet2021}:
M-mode software can determine whether a privilege mode is implemented by writing that mode
to MPP then reading it back.
If the machine provides only U and M modes, then only a single hardware storage bit is
required to represent either 00 or 11 in MPP.



\section{Core-v-verif binaries: \Cref{req:binaries}}

%\todo{bare metal. Using spike-pk?}
%
%Spike can be run with a proxy kernel or "bare metal": 
%spike-pk is a proxy kernel and boot loader. It is an execution environment that runs RISC-V ELF binaries and allows them to do system calls. It manages memory locations.

%\subsection{spike startup}
%
%describe spike startup: \url{https://github.com/riscv-software-src/riscv-isa-sim/issues/145}
%\url{https://github.com/poweihuang17/Documentation_Spike}
%
%
%
%
%\subsection{Spike with core-v-verif binary}




%\url{https://github.com/openhwgroup/core-v-verif/tree/master/cv32e40s/bsp}
The binaries used in core-v-verif is built using the \acrfull{bsp} provided with core-v-verif in \lstinline{cv32e40s/bsp}. This contains initialization tasks(\lstinline{ctr0.s}), interrupt and exception handling (\lstinline{vectors.S, handlers.S}), syscall implementations (\lstinline{syscalls.c}) and a linker script (\lstinline{link.ld}) \cite{CorevverifCv32e40sBsp}. The \acrshort{bsp} is used to compile to a bare-metal system.

The linker script has two sections, \lstinline{ram} and \lstinline{dbg}. The ram starts at \lstinline{0x0} and has a size of \lstinline{0x400000} (4MB). Dbg...

When running spike with a binary generated with core-v-verif we run into problems.

Spike always starts running at the \lstinline{DEFAULT_RSTVEC = 0x1000}. Spike places a boot rom at this reset location that contains the 8 instructions long reset vector code and the binary device tree data \cite{evancoxAddDocumentationLowlevel2017}.
After this is run, spike will jump to the provided program counter or to the \lstinline{_start} symbol from the ELF file.

Aditionally, spike has a debug module in memory.

When running spike with a binary compiled with the \acrshort{bsp} we get an error saying \lstinline{memory address 0x0 is invalid}, because spikes boot rom and debug module conflicts with the corev ram. 

In order to use spike with the binaries generated with core-v-verif, some modifications need to be done

To avoid this conflict we can either modify the linker script to move the memory locations in the binaries, or modify spike to work with the core-v-verif binaries. By modifying \lstinline{link.ld} we also need to modify the boot address and memories of the core, but if we modify Spike, all the other components in core-v-verif can remain intact. We therefore want to modify spike to keep the core-v-verif components intact. Since we want to be able to switch out spike with another ISS, we don't want to conform to restrictions from spike.

\subsubsection{Spike modifications}

To avoid conflicts, the reset vector and debug module from spike must be disabled. Spikes default boot loader can be disabled by setting \lstinline{dtb_enabled = false} and the debug module can be removed from the \lstinline{sim_t} class.

To run the core-v-verif binaries, spike must be configured with 3 memory regions. Ram from \lstinline{0x00000000} with size \lstinline{0x400000}, Debug from \lstinline{0x1a110800} with size \lstinline{0x1000}, and corev virtual registers from \lstinline{0x00800000} with size \lstinline{0x1000}. The corev virtual registers contain registers used for example to write to stdout etc.\tmp{TODO: forklar virtual registers i bakgrunn?}

These modifications allow an elf file generated with core-v-verif to run successfully in spike.
%\subsection{linker}
%
%One notable difference between the cva6 and cv32e40s elf binary is the linking. When looking at the output of readelf for both tests, CVA6 starts at 80000000, while cv32e40s starts at 00000000. CVA6 uses the linker script at verif/tests/custom/common/test.ld. This is a proxy kernel linker script.
%
%
%I tried modifying the linker script and move the ram from 0x00000000 to 0x08000000 and the starting address to 0x08000080. By using the -m0x08000000:0x400000 spike flag the memory address ... is invalid error no longer arrives but I get a warning: warning: tohost and fromhost symbols not in ELF; can't communicate with target
%And I get this



\section{Step through individual instructions: \Cref{req:step}}

\subsection{Modification of Spike}

Pure spike runs from \lstinline{spike.cc} in the main function. The main execution is done by instantiating a \lstinline{sim_t} that gets configured with the processor and memory. The construction in \lstinline{sim_t} instantiates a configurable amount of \lstinline{prcessor_t} processor types. The original implementation from main fully runs spike until completion using the \lstinline{sim_t::run()} function.

To use Spike in the reference model, we need a way to interface with Spike to only run one instruction and return the state changes from this instruction. This requires some modification. 

We want to use DPI functions to interface with Spike from the reference model. To do this we need to instantiate spike in a dpi wrapper instead of running it from the main function. We want an initialization function that instantiates and configures spike, and a step function to step through one instruction and return the state changes as an RVFI output. We also need a function to inject interrupts into spike.

The init function should load the binary to be run, and configure the processor.

\lstinline{sim_t} has a method called \lstinline{step()} that steps through a given number of instructions in each of the configured processors. 
We can not simply instantiate a \lstinline{sim_t} object in the dpi file because this step method is private and does not return the required RVFI state changes.

One way to achieve this is to make a new class that inherits from \lstinline{sim_t} and instantiate this in the dpi wrapper. This class can publicly expose a step function that returns an RVFI output, and also abstract away some configuration details to clean up the dpi wrapper. 

In order to return an RVFI output we need to construct an RVFI item from the internal state changes in Spike. The \lstinline{processor_t} class exposes its state struct via the \lstinline{get_state()} method and this can be used to generate the rvfi item.
One problem is that the \lstinline{state_t} does not contain all necessary components to make an rvfi item, so features like the last instruction need to be added.


The CVA6 spike implementation has done just that. The CVA6 spike implementation is also integrated into core-v-verif, and if we can make this work this could be beneficial to avoid multiple versions of spike in core-v-verif for each core. This Spike version is fairly customized to the CVA6 core, so using this version also requires a good amount of modification.
This is also under development so changes can be made to this version that might break our integration in the future.



\section{Return RVFI after instruction: \Cref{req:state}}

\subsection{RVFI problems}
RVFI from CVA6 is sometimes off. RVFI signals are generated by calling \lstinline{insn.rs1()} which selects the correct number of bits from the insn. This is a problem when the RISC-V format does not include this field. For example the insn \lstinline{addi x3, x3, 1224} is an I-type instruction, with only rs1 and rd registers, and not rs2. When RVFI items are generated and \lstinline{insn. rs2()} is called, it does not consider the instruction type and incorrectly stores the rs2 bits that in the case of an I-type overlap with the Imm bits, leading to an incorrect rs2 rvfi item.

\lstinline{rd1_wdata} has a mismatch when performing certain jump instructions like 


\subsection{Adding the memory section to rvfi}

CV32E40S has expanded rvfi to support multiple memory operations per instructions\cite{openhwgroupRISCVFormalInterface2023a}. Since all RV32I instructions support single memory operations we will implement this first.

For logging, spike stores stores all register and memory commits during an instruction. This can be used to generate the rd and mem rvfi signals. Register commits are stored in the unordered map \lstinline{log_reg_write} with register number and data, memory read and write commits are stored in vectors of tuples with addr, value, and size.

To get the memory address we can use store the address into \lstinline{}
We can use these tuples to generate rvfi signals like this \tmp{TODO: legg inn kodelinje}

\subsection{rvfi interrupts and traps}

The \lstinline{rvfi_intr} signal should he asserted on the first instruction of the interrupt handler. 

For exceptions (traps), the \lstinline{rvfi_trap} signal is asserted the instruction the trap occurs, while \lstinline{rvfi_intr} is asserted on the next instruction, which is the first instruction of the trap handler. The signals of the trap and intr signals are the same, so when a trap occurs, we can store the signals to a variable \lstinline{next_rvfi_intr}. At the next step we can output this to \lstinline{rvfi_intr}.

For interrupts, we should only output \lstinline{rvfi_intr} and not \lstinline{rvfi_trap}. When taking an interrupt, spike must call the step function two times, one time to take the interrupt, and the second to actually execute the first instruction of the interrupt handler. In spike, the information about the interrupt is generated during the first step and \lstinline{taken_trap} stores if an interrupt or trap happens, and \lstinline{which_trap} holds the cause of the trap/interrupt. Aditionally the MSB of signals wether the trap is for an exception or interrupt. Since we only collect the rvfi data from the second step when taking interrupts, we generate the \lstinline{rvfi_intr} signals in the first step when the trap data is available, and store this to \lstinline{next_rvfi_intr}, which is output to \lstinline{rvfi_intr} at the next step, along with the interrupt handler.



\subsection{rvfi interface}

CVA6 spike exports an \lstinline{st_rvfi} struct which is very simplified rvfi. To add signals like \lstinline{rvfi_valid} we create a new interface called \lstinline{rvfi_if_t} that is passed from the pipeline shell to the reference model wrapper. 






\section{Interrupt injection: \Cref{req:interrupt}}

The interrupt interface in CV32E40S has some interrupt signals tied to 0. For spike to properly simulate this we need a way to disable certain irq signals. One way to do this is to define a mask of disabled and enabled irq signals.


To insert interrupts into Spike we can define a DPI function \lstinline{spike_set_mip(irq)} to set the correct mip bits to take the interrupt. This function can be called from the \lstinline{iss_intr(irq)} systemverilog function.

In order to access the processor state in spike to set and read CSR registers, we do the actual modification of CSRs in the method \lstinline{Simulation::set_mip(reg_t mip)} in the Simulation class, which has access to the \lstinline{Processor} type where the CSRs and state is stored.

This function sets the \lstinline{mip} CSR register with the given data. The CV32E40S core only has some of the interrupt pins enabled, and some pulled to 0\cite{openhwgroupExceptionsInterruptsCOREV2023}. In order to only be able to set the wired interrupts, one solution is to use a make \lstinline{ENABLED_IRQ_MASK}, and use this when writing the mip to the CSR using \lstinline{mip->write_with_mask(ENABLED_IRQ_MASK, mip)}, to only write the wired up interrupt lines.


To precisely control when interrupts are taken from the pipeline shell, we want to both set the mip bits, and execute the first instruction of the trap handler. For spike to execute the first instruction of the trap handle, spike needs to be stepped two times after the \lstinline{mip} bits have been set. The first step only sets the correct PC and state, while the second step actually steps through the instruction. When choosing when to run these step functions there are multiple options.

We do not want to run two steps every time \lstinline{set_mip()} is called, but only when we know the interrupt will be taken at the next step. This depends on wether \lstinline{mstatus.MIE} is set to enable interrupts, if the interrupt is enabled in the \lstinline{mie} CSR, and if we are not in debug mode. We therefore need to check all of this before calling the first step function. This requires reading multiple CSR registers and the debug state. It therefore make sense to check these conditions and run the first step from inside \lstinline{Simulation::set_mip()}. Additionallly, we do not need the generated RVFI values from this step as it does not step through an instruction, so this can be discarded.

We also have to tell spike when the interrupt bits have been cleared. By checking in \lstinline{set_mip()} if the mip is not 0 before calling the step function, we can use the same method to clear the mip bits. When clearing the bits we do not want the function to step through an instruction.

In order to avoid steps when clearing mip bits we separate \lstinline{iss_intr()} and \lstinline{iss_step()}. By doing this we also avoid implementing RVFI output from \lstinline{iss_intr()} since this is not needed when it is used to clear mip bits or when interrupts are not enabled. 

In order to inject an interrupt into spike from systemverilog, we first call \lstinline{iss_intr(irq)} with the \lstinline{irq} bits to set, and the we call \lstinline{iss_step()} to step through the first instruction of the trap handler and generate the corresponding RVFI output.


\subsection{Directed Interrupt test}
\tmp{TODO: Burde disse testene under resten av seksjonen flyttes til pipeline shell istedenfor?}

To test if the pipeline shell works while implementing it, it is beneficial to have a standard directed test to use while developing the pipeline shell.
This test should fail before implementing the pipeline, but pass when it is implemented.

The core-v-verif tests use virtual peripheries to set interrupts. 
The two registers \lstinline{TIMER_REG_ADDR} and \lstinline{TIMER_VAL_ADDR} are used to set the irq value and delay to set.  

The virtual periphery reads these registers and stores the interrupt value to \lstinline{interrupt_value} or \lstinline{clic_value}, stores the timer delay, and starts the timer. This is done by calling\lstinline{interrupt_timer()} in \lstinline{uvma_obi_memory_vp_interrupt_timer_seq.sv}, which waits for the given delay, before calling \lstinline{set_interrupt()} which sets the \lstinline{irq} signal to the stored interrupt value. 

This allows tests to be written that can trigger "external" interrupts from the test code to accurately time interrupts with the code.

The first test that should pass is just passing in a simple interrupt. To do so, we first enable the MIE bit in mstatus, then enable the mie bit of the interrupt we want to set. To set the interrupt, we use \lstinline{mm_ram_assert_irq(0x1 << interrupt, 1}, which sets \lstinline{TIMER_REG_ADDR} to the mask of enabled interrupts, and \lstinline{TIMER_VAL_ADDR} to the cycle delay before asserting the interrupt.

After setting the interrupt to be triggered in 10 cycles, we do some add instructions.




\subsection{Implementation 0}

In the first implementation the pipeline shell is not implemented and just calls the \lstinline{step()} dpi function when the core retires an instruction. This functions correctly with synchronous execution, but not when interrupts are introduced. 

In this implementation, interrupts are inserted into the core with \lstinline{iss_intr(irq)}, which again calls \lstinline{spike_set_mip(irq)} to set the correct mip bits in spike. 
Implementation 0 calls \lstinline{iss_intr} on the first clock posedge when the \lstinline{irq_drv} signal from the interrupt interface changes.

\subsubsection{Results}

When running the Directed interrupt test with this implementation, the interrupt is taken at different times in the core and the reference model. The core executes two more instructions compared to the reference model. 


%\noindent
\begin{minipage}{.45\textwidth}
\vspace*{0pt}
\begin{lstlisting}[caption=Core,frame=tlrb]{Name}
 PC       | INSTRUCTION
 0000134c | c.lwsp x15,12(x2)
 0000134e | c.addi x15,1
 00001350 | c.swsp x15,12(x2)
 00001352 | c.lwsp x15,12(x2)
 00001354 | c.addi x15,1
 00001356 | c.swsp x15,12(x2)
 00001358 | c.lwsp x15,12(x2)
 0000000c | INTR 3
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
\vspace*{0pt}
\begin{lstlisting}[caption=RM,frame=tlrb]{Name}
 PC       | INSTRUCTION
 0000134c | c.lwsp x15,12(x2)
 0000134e | c.addi x15,1
 00001350 | c.swsp x15,12(x2)
 00001352 | c.lwsp x15,12(x2)
 00001354 | c.addi x15,1
 0000000c | INTR 3
\end{lstlisting}
\end{minipage}



\subsection{Implementation with RVFI synced interrupt input}

When an interrupt is flagged with RVFI, we use \lstinline{iss_intr(irq)} to take the interrupt in spike. When setting the mip csr with the interrupt and stepping, the instructions are delayed one instruction behind the core.

When spike steps through an instruction in \lstinline{execute.cc} it first tries to take any pending interrupts with \lstinline{take_pending_interrupt()}. This will throw a \lstinline{trap_t} which will stop the execution of the current instruction and instead call \lstinline{take_trap()} which changes the PC to the trap handler and sets the state, but does not step into the first instruction of the trap handler. 

In order for \lstinline{iss_intr(irq)} to set the mip, and execute the first instruction of the trap handler, the step function in spike needs to be called two times. One time to set the state and one time to step the instruction.

By doing this the interrupt is correctly timed, but the mip is not cleared, so the interrupt is taken again.

When clearing the mip, or when setting the mip will not lead to an interrupt being taken, we do not want to step spike. It is therefore necessary to check if the interrupt will be taken before doing the extra step in spike.

\subsubsection{Results}

Spike synced with rvfi passes the custom directed test with an enabled interrupt, but fails test 1 from \lstinline{interrupt_test} which applies interrupt signals when interrupts are disabled. When reading the \lstinline{mip} CSR after it should be set to \lstinline{0x00000008}, the RM reports \lstinline{0x00000000}. This is because this implementation only sets the \lstinline{mip} CSR when the core reports taking an interrupt. Therefore when interrupt signals are applied, but interrupts are disabled, the core will not report an interrupt and the CSRs will be different.


\subsection{Async interrupts without pipeline shell }

Instead of syncing interrupts with the core using RVFI, interrupts are now passed directly into spike and are immediately taken on the next retirement from the core. This implementation is intended to highlight the problem with passing interrupts directly into the ISS.

\subsubsection{Result}

When running the directed test with interrupts passed directly into spike, we can see the trace log in \cref{lst:async_int_1}. This shows that the Interrupt is applied between \lstinline{PC=0x00001352} and \lstinline{0x00001354}. The Refference model takes the interrupt immediately at the next retirement, but the core waits 3 more retirement before jumping to the trap handler. The number of instructions delayed can also is also different depending on what instructions are in the pipeline.

\begin{lstlisting}[label={lst:async_int_1},caption={Trace output from asynchronous interrupts without pipeline shell}]

PC CORE  (INSN)     | PC RM     (INSN)
------------------------------------------
0000134e (00000785) | 0000134e, (00000785) 
00001350 (0000c63e) | 00001350, (0000c63e) 
00001352 (000047b2) | 00001352, (000047b2) 
Interrupt applied:00000008
RM Intr taken
00001354 (00000785) | 0000000c, (6b80006f) 
00001356 (0000c63e) | 000006c4, (0000b84e) 
00001358 (000047b2) | 000006c6, (fea12c23) 
Interrupt applied:00000000
Core Intr taken
0000000c (6b80006f) | 000006ca, (0000450d) 
000006c4 (0000b84e) | 000006cc, (0000c216) 
000006c6 (fea12c23) | 000006ce, (0000c01a) 
000006ca (0000450d) | 000006d0, (fe712e23) 
000006cc (0000c216) | 000006d4, (feb12a23) 
\end{lstlisting}


\section{\Cref{req:revertState}: Revert state}

To revert spike to a previous state there are some options.

Since spike executes the entire instruction before entering the pipeline, spike has already executed instructions that might need to be discarded because of a pipeline flush. We therefore need a way to revert changes made in spike for instructions that are still in the pipeline.

The operations that need to be reverted are writes to the register file, writes to \acrshort{csr}s, and writes to the memory.

\subsubsection{Store full state in pipeline shell}

\subsubsection{Revert based on state changes stored in pipeline shell}

\subsubsection{Store x previous states in spike, and revert}

Spike has a struct called \ccode{state_t} that contains the PC, registers, and csrs. This can be storred to revert the state. 

If memory writes have been executed during the execution, it gets more complicated, as this is not stored int the \ccode{state_t} struct. To handle we must either find a way to store the memory for each instruction, figure out if only the cache or tlb\textbf{????} can be stored, or store the values before a change than can be stored back into memory.

\subsubsection{Spike memory}

\url{https://github.com/poweihuang17/Documentation_Spike?tab=readme-ov-file#Memory}

On a store instruction like \rv{sw} the following is executed in spike \ccode{MMU.store<uint32_t>(RS1 + insn.s_imm(), RS2);} which translates to \ccode{*p->get_mmu().store(RS)}. This returns the \ccode{mmu_t* mmu} from \ccode{processor_t}.

The store method checks the TLB and stores the value with \ccode{store_slow_path} and \ccode{store_slow_path_intrapage()} which actually stores the value using \ccode{memcpy(host_addr, bytes, len);}. The \ccode{host_addr} is either found in the TLB or calulated and inserted if not in the TLB. 


The memory regions like ram are created with \ccode{this->mems.push_back(std::make_pair(dram_base, new mem_t(dram_size)));}
which creates a new \ccode{mem_t}. This contains a memory map \ccode{std::map<reg_t, char*> sparse_memory_map;}

Storing to memory involves using \ccode{memcpy} with an address from \ccode{mem_t::contents(reg_t addr)}
This searches the \ccode{sparse_memory_map} to find the key value pair with the page the address is on. If the address is not in the \ccode{sparse_memory_map}, it allocates a page using \ccode{auto res = (char*)calloc(PGSIZE, 1);}, adds this to the \ccode{sparse_memory_map} and returns the address as \ccode{page + pageoffset}.

\subsubsection{Storing a copy of memory for every instructions}

The use of the \ccode{sparse_memory_map}, storing the location of memory pages, it makes it somewhat difficult to store multiple versions of the memory along with each instruction in the pipeline. Simply copying the memory map is not enough as it does not hold the actual values. Instead is is necessary to copy each page of the memory map into another memory map and allocate space for these individually. 

Additionally the TLB also has to be updated.

This gets even more complicated when using a cache, as this also has to be correctly updated and reverted. 


\subsubsection{Storing the changes to memory for every instruction. (or values before memory operation)}

A more general and less implementation specific approach could be to store the values in a memory location before it is being written to. This must be kept while the instruction that executed the memory operation is in the pipeline. When the pipeline is flushed, each of these memory operations has to be reverted back to its original state. This allows us to use the top level memory interface, which would automatically handle the TLB, caches, and storing to the correct memory address on the correct page.

The \ccode{state_t} already contais commit logs holding reads and writes to registers and memory, used to make the execution log from spike. The memory logs hold address, value, and size on the form \ccode{typedef std::vector<std::tuple<reg_t, uint64_t, uint8_t>> commit_log_mem_t;} from \file{processor.h}. The commit log is written to in \ccode{store()} in \file{mmu.h}.

We are interested in the value before writing, and not the value stored in the commit log, which is the value after writing. 

We can therefore expand the \ccode{state_t} to hold a commitlog of values before writing called \ccode{log_mem_pre_write} and store to that in the \ccode{store} function.

To load the memory values before writing to them, we can either use the \ccode{load()} function from inside \ccode{store()} or directly use the relevant lines from \ccode{load()} in \ccode{store()}. If we were to call the \ccode{load()} function, this would also store to the \ccode{log_mem_read} commit log, which would affect the generated RVFI output and spike execution log. We would therefore have to clear the \ccode{log_mem_read} after running \ccode{load()} or disable the commit log before running it.

Since the address generation from \ccode{load()} and \ccode{store()} are similar, we can easily add the relevant lines of code from \ccode{load()} to \ccode{store()}. The expanded \ccode{store()} from \file{mmu.h} is shown in \Cref{lst:store} with the added lines marked with \ccode{+}.


\begin{clisting}[caption={Modified \ccode{store()} function from \file{mmu.h} with new lines marked with \ccode{+}.}, label={lst:store}]
  template<typename T>
  void ALWAYS_INLINE store(reg_t addr, T val, uint32_t xlate_flags = 0) {
    reg_t vpn = addr >> PGSHIFT;
    bool aligned = (addr & (sizeof(T) - 1)) == 0;
    bool tlb_hit = tlb_store_tag[vpn % TLB_ENTRIES] == vpn;
    target_endian<T> previous_value;


    if (xlate_flags == 0 && likely(aligned && tlb_hit)) {
+     //Store previous value before writing
+     previous_value = *(target_endian<T>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr);

      *(target_endian<T>*)(tlb_data[vpn % TLB_ENTRIES].host_offset + addr) = to_target(val);
    } else {
+     //Store previous value before writing
+     load_slow_path(addr, sizeof(T), (uint8_t*)&previous_value, xlate_flags);

      target_endian<T> target_val = to_target(val);
      store_slow_path(addr, sizeof(T), (const uint8_t*)&target_val, xlate_flags, true, false);
    }

    if (unlikely(proc && proc->get_log_commits_enabled())) {
      proc->state.log_mem_write.push_back(std::make_tuple(addr, val, sizeof(T)));
+     proc->state.log_mem_pre_write.push_back(std::make_tuple(addr, from_target(previous_value), sizeof(T)));
    }
  }
\end{clisting}



\subsubsection{Storing states for instructions}

Since we store the \ccode{log_mem_pre_write} in the \ccode{state_t} it should be sufficient to only store this state struct for each instruction in the pipeline to store the registers, \acrshort{csr}s, and memory operation for each instruction. 

To avoid converting this struct to systemverilog, and back to C++, it is easier to store this state \textit{snapshots} in Spike, and use a DPI function call from the pipeline shell to signal which snapshot to revert back to.

Because we only need the states for the instructions that are currently in the pipeline, we only need to store a set number of previous states. If we in the future want to use a synthesizable ISS, this method can be advantageous as fixed size array is easier to synthesize than a dynamic array.

In Spike we can store the previous states in a \ccode{deque} double-ended queue. This makes it easy to insert the most recent state at the beginning of the queue, and remove the oldest state from the end of the queue when the instruction leaves the pipeline. 
We can also easily access items at a specific index to revert the state to a given previous state.

\tmp{Where to store state}


\tmp{When to store state}

\subsection{Reverting state}

The order of events when reverting the state is important to get right.
If this is the order

\begin{enumerate}
    \item Interrupt input into RM
    \item Spike mip set to irq. Returns if interrupt will be taken
    \item Flush pipeline
    \item Revert state
\end{enumerate}

In the example above, the mip, pc, cause, status, etc set with \ccode{spike_set_mip()} is overwritten when reverting the state. 

We should either store the mip, revert the state, then store back the mip, or revert the state before setting the mip.

To revert the state before setting the mip, we need a way of determining if the interrupt will be taken before setting the mip. 

\subsubsection{Testing revertion}

\ccode{revertTest()} places an interrupt after a store operation to see if the state and memory operation is reverted.

The required number of instructions to revert differs between the revertTest and division test. In the revertTest, the core retires two? instruction after mip is set
\begin{terminal}
   20514.000 ns | IF 000013dc  1| ID 000013da 1| EX 000013d8 1 | WB 000013d6 1 | RVFI 000013d4 1|| ID 000013d8 | EX 000013d6 | WB 000013d4 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | C_ADDI   | 000013d4
   20517.000 ns | IF 000013de  1| ID 000013dc 1| EX 000013da 1 | WB 000013d8 1 | RVFI 000013d6 1|| ID 000013da | EX 000013d8 | WB 000013d6 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | C_ADDI   | 000013d6
   20520.000 ns | IF 000013e0  1| ID 000013de 1| EX 000013dc 1 | WB 000013da 1 | RVFI 000013d8 1|| ID 000013dc | EX 000013da | WB 000013d8 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | C_ADDI   | 000013d8
   20523.000 ns | IF 000013e2  1| ID 000013e0 1| EX 000013de 1 | WB 000013dc 1 | RVFI 000013da 1|| ID 000013de | EX 000013dc | WB 000013da || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | C_ADDI   | 000013da
MIP set to: 00010000
   20526.000 ns | IF 000013e4  1| ID 000013e2 1| EX 000013e0 1 | WB 000013de 1 | RVFI 000013dc 1|| ID 000013e0 | EX 000013de | WB 000013dc || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | C_ADDI   | 000013dc
   20529.000 ns | IF 000013e8  0| ID 000013e4 0| EX 000013e2 0 | WB 000013e0 0 | RVFI 000013de 1|| ID 00000000 | EX 00000000 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
MIP set to: 00000000
   20532.000 ns | IF 00000040  0| ID 000013e4 0| EX 000013e2 0 | WB 000013e0 0 | RVFI 000013de 0|| ID 00000040 | EX 00000000 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   20535.000 ns | IF 00000040  0| ID 000013e4 0| EX 000013e2 0 | WB 000013e0 0 | RVFI 000013de 0|| ID 00000856 | EX 00000040 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   20538.000 ns | IF 00000040  1| ID 000013e4 0| EX 000013e2 0 | WB 000013e0 0 | RVFI 000013de 0|| ID 00000856 | EX 00000040 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   20541.000 ns | IF 00000044  0| ID 00000040 1| EX 000013e2 0 | WB 000013e0 0 | RVFI 000013de 0|| ID 00000856 | EX 00000040 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   20544.000 ns | IF 00000856  0| ID 00000040 1| EX 00000040 1 | WB 000013e0 0 | RVFI 000013de 0|| ID 00000856 | EX 00000040 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   20547.000 ns | IF 00000856  0| ID 00000040 0| EX 00000040 1 | WB 00000040 1 | RVFI 000013de 0|| ID 00000856 | EX 00000040 | WB 00000000 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 |
   20550.000 ns | IF 00000856  1| ID 00000040 0| EX 00000040 0 | WB 00000040 1 | RVFI 000013de 0|| ID 00000856 | EX 00000040 | WB 00000000 || ia 0 | li 1 / 1 | db 1 | f 0 | cp 0 | si 0 | ib 0 | cf 0 | sl 0 |
   20553.000 ns | IF 00000856  1| ID 00000856 1| EX 00000040 0 | WB 00000040 0 | RVFI 00000040 1|| ID 00000858 | EX 00000856 | WB 00000040 || ia 1 | li 1 / 1 | db 1 | f 0 | cp 0 | si 1 | ib 0 | cf 0 | sl 0 | RVFI | JAL      | 00000040    
\end{terminal}

\subsubsection{How many states to revert?}

We do not always want to revert the same number of states. This is shown when running \ccode{revertTest} and \ccode{divisionTest}. In the first test the interrupt is injected in the middle of multiple \rv{addi} instructions, that retire every clock, while in the division test, the interrupt is injected in the middle of a long division operation.

In the \rv{addi} example, reverting 2 instruction is sufficient, while in the \rv{divu} example, we need to revert 3 instructions??


When taking an interrupt in the core, W


\tmp{is the revertion isntruction the same as mepc?}

test

\tmp{Could the state be reverted inside spike set mip}

s

\tmp{How does the revert function work?}

s
\tmp{when is it called?}
d
\tmp{make sure the correct state is chosen}
f
\tmp{make sure memory is reverted properly}
d
\tmp{make sure mepc is set correctly after rewrite}

\section{Custom instructions:\Cref{req:custom}}

\tmp{ZCMP supports multiple memory operations per instruction. This affects RVFI}

\tmp{Also supports multiple RD writes, which must also be handled with RVFI}

\section{Update: \Cref{req:update}}

\section{Problems and solutions}

\begin{enumerate}

\item \textbf{Issue:} \lstinline{mem_rdata} is 0 when using \lstinline{mem_read_commits}
  \begin{description}
    \item[Cause:] Spike only stores the address of memory reads, but stores both address and value for writes.
    \item[Resolution:] [Spike] The read value should be the same as rd, so we can use the rd value as the memory read value.
  \end{description}

\item \textbf{Issue:} Wrong address with multiple memory accesses in one instruction. This is a problem with Zcmp.
  \begin{description}
    \item[Temporary Fix:] [Compare] Disable for now. \textbf{TODO:} Handle multiple memory accesses.
  \end{description}

\item \textbf{Issue:} \lstinline{mem_rdata} mismatch between RM and Core
  \begin{description}
    \item[Resolution:] [Compare] Only the \lstinline{mem_wdata} and \lstinline{mem_rdata} bytes that are high in \lstinline{mem_(w/r)mask} should be compared, as the other bytes can be different.
  \end{description}

\item \textbf{Issue:} \lstinline{rd1_wdata} is sometimes mismatched
  \begin{description}
    \item[Cause:] When \lstinline{rd1_addr} is 0, \lstinline{rd1_wdata} data is not guaranteed to be 0.
    \item[Resolution:] [Compare] Only check \lstinline{rd1_wdata} if the address is not 0.
  \end{description}

\item \textbf{Issue:} \lstinline{csr_priv_gen_test} insn mismatch at PC \lstinline{0x00000000}

\item \textbf{Issue:} Trap mismatch for illegal instruction type
  \begin{description}
    \item[Cause:] Spike generated wrong rvfi for trap.
    \item[Resolution:] [Spike] Generate correct trap rvfi in spike.
  \end{description}

\item \textbf{Issue:} Interrupt mismatch
  \begin{description}
    \item[\textbf{TODO:}] Interrupt rvfi must be added. The \lstinline{intr} signal must be delayed until the first instruction of the interrupt handler.
  \end{description}

\item \textbf{Test:} \lstinline{cv32e40s_readonly_csr_access_test}:
  \begin{description}
    \item[Issue:] \lstinline{rd1_addr} mismatch on \lstinline{csrrs} instruction causing trap.
    \item[Cause:] TODO
    \item[Resolution:] [Compare] Ignore \lstinline{rd1_addr} on trap.
  \end{description}

\item \textbf{Test:} \lstinline{cv32e40s_csr_access_test}:
  \begin{description}
    \item[Issue:] In the core \lstinline{mcycle} is 0 after 3 instructions, but in Spike it is 3.
    \item[Cause:] \lstinline{mcountinhibit} is 0 in RM and 5 in core and \lstinline{mcycle} is increased regardless of \lstinline{mcountinhibit}
    \item[Resolution1:] [Spike] Reset \lstinline{mcountinhibit} to 5 like in the core.
    \item[Resolotion2:] [Spike] Check if the \lstinline{mcountinhibit} bit is high before increasing (or not) \lstinline{mcycle} in spike.
  \end{description}

\item \textbf{Issue:} \lstinline{mcycleh} is 2 when core is 0
  \begin{description}
    \item[Cause:] Spike has "hack" to add one on write to take into account the coming bump of \lstinline{mcycle} \texttt{FFFFFFFF}.
    \item[Resolution:] \textbf{FIX(ish):} Revert a hack that adds 1 to account for upcoming bump. TODO: make sure modifications work for all cases.
  \end{description}

\item \textbf{Issue:} \lstinline{mstatus} mismatch \lstinline{core = 0x00201880 and rm = 0x00200080}
  \begin{description}
    \item[Problem:] The difference is \lstinline{MPP = 3} for core and 0 for RM.
    \item[\textbf{TODO:}] \tmp{This is not solved yet}
  \end{description}
  
\item \textbf{Issue:} CSRs are wrong in hello world test
  \begin{description}
    \item[Cause:] CSRs (\lstinline{marchid, misa, mvendorid, and mimpid}) are configured differently in spike and core
    \item[Resolution:] Change CSRs in \lstinline{state_t::reset()} in \lstinline{processor.cc}.
  \end{description}
  
\item \textbf{Issue:} RVFI mismatch: cm.popret reports rd1 = x0 from core but rd1 = x2 from RM 
  \begin{description}
    \item[Cause:] RVFI reporting is done differently
    \item[Resolution:] [Spike] Check if the instruction is a popret instruction and set rd1 to 0 if it is in 
  \end{description}

\item \textbf{Issue:} When setting all mie bits in spike, only bit 3, 7, and 11 are set. Bit 16-30 used for custom interrupts are not set 
  \begin{description}
    \item[Cause:] The \lstinline{csrrw} instruction writes a csr with a mask. The mask for writing to \lstinline{mie} is generated using \lstinline{reg_t mie_csr_t::write_mask} in \lstinline{csrs.cc}. This does not enable all custom interrupt bits(16-31) like the core does.
    \item[Resolution:] [Spike] Add custom interrupt bits (16-31) to mie write mask in spike
  \end{description}
  

\item \textbf{Issue:} RVFI intr signal is incorrectly timed. The trap signal should be active when the trap arrives, but the intr signal should be active on the first instruction of the trap handler.
  \begin{description}
    \item[Cause:] 
    \item[Resolution:] [Spike] Store the rvfi trap signal until the next step, when the rvfi intr signal is set to the previous trap signal
  \end{description}

\item \textbf{Issue:} Differentiate between trap and interrupt to output correct rvfi.intr signal.
  \begin{description}
    \item[Cause:] When spike takes an interrupt it throws a \lstinline{trap_t(cause)} and sets the msb of cause to 1 to show the trap is an interrupt. When a synchronous trap is encountered, the cause is not marked with the high msb. This cause is stored in the \lstinline{which_trap} variable in the \lstinline{Processor} class, but this is stored as an \lstinline{uint8_t}, which discards the information stored in the msb.
    \item[Resolution:] [Spike] By changing \lstinline{which_trap} to an \lstinline{uint32_t} we can differentiate between interrupts and traps when building the rvfi signals.
  \end{description}


  
\end{enumerate}
