\chapter{Formal Verification}
\label{ch:formal}

\section{core-v-verif Onespin integration}

In order to support formal verification, one contribution of this thesis is a script that configures Onespin \cite{onespinsolutionsgmbhUserManualOneSpin} to support the CV32E40S core. This contribution is the addition of the file \file{onespin.tcl} found in \Cref{app:onespin.tcl}. This loads the correct files and configures the core for formal verification in Onespin. 

Onespin needs signals to drive in order to test different inputs. By default, these signals are already driven in the testbench, so these need to be disconnected or \textit{cut} for the signals to show up as inputs and be drivable by onespin. This can be done with the \lstinline{add_compile_option -cut_signal clknrst_if/clk}.

To get Onespin setup, Onespin needs a clock and reset signal to drive. We therefore cut \sv{clk} and \sv{reset}.


To test different instructions, we can inject values into the obi interface by cutting the signals in \lstinline{obi_instr_if} and \lstinline{obi_data_if}.


\section{Formal verification testbench}

Since Spike is written in \cpp, it is incompatible with formal verification. To support formal verification in the future by switching to a formal-friendly ISS, we want the rest of the reference model to be compatible with formal verification. In addition to the simulation-based testbench, we want to verify the design using formal methods. To do this, we replace \lstinline{iss_wrap_pkg.sv} that communicates with Spike, with a "dummy ISS " in \lstinline{iss_wrap_formal_pkg.sv} that is mostly empty but can be used to verify that the rest of the reference model works with formal methods.

For the dummy ISS interface to be used by the rest of the reference model, it should have the same interface and return \acrshort{rvfi} signals. Since we do not have a working formal ISS, we can either output a static \acrshort{rvfi} item or return the same \acrshort{rvfi} signals as the core. We can also verify that the comparison functionality works by returning the same RVFI signals as the core.


We would then have two environments: a UVM simulation environment that verifies the correctness of the reference model using a \cpp \acrshort{iss}, and a formal verification environment that does not test the functionality of the reference model, but checks that the reference model can run in a formal verification environment when using an RTL simulator.

If both these tests pass, future work should be to replace the dummy ISS in the formal environment with sail-riscv when the SystemVerilog generator is fully supported and verify that this works. 


