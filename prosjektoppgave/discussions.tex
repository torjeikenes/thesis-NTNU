\chapter{Discussions \& Future Work}
\label{Discussions} 
In this report, we have explored design choices for a cycle-accurate reference model, with the goal of accurately simulating the correct behavior of asynchronous events like interrupts and debug requests and the correct timing of side effects. We discussed implementing a pipeline shell on top of an existing Instruction Set Simulator to achieve this, as this gives a practical partitioning between the core-independent ISS and the pipeline shell that can be reconfigured for different cores. 

In \cref{sec:pipelineShell}, we identified the necessary components for a comprehensive pipeline simulation. We proposed mapping out the simulation components to simplify the simulator by making a dependency tree and applying the method to the CV32E40X core. This allows us to visually see all the aspects that affect the timing of interrupts and use this to show what simplifications can be made. However, further work should go into analyzing the dependency tree and applying different simplifications. The approach used here also has several drawbacks. To make the dependence tree as detailed as possible, the RTL code of the CV32E40X was used to find the dependencies. In general, using the code in order to model the reference model can be problematic. This is because if there is a bug in the code, this can now also propagate to the reference model, leading to the same bug happening in the DUT and the reference model. Additionally, the dependency tree is specific to the CV32E40X core, so implementation details of other cores might differ. However, the dependence tree can still be useful for visualizing the complexity of interrupt timing and giving a general idea of what can be abstracted away.

Two implementation choices were proposed in \cref{sec:pipelineShell} for modeling the pipeline shell, the stage-based approach (\cref{sec:stagebased}) and the time wheel approach (\cref{sec:timeWheel}). As discussed in \cref{sec:stageWheelComp}, the stage-based approach is more straightforward and intuitive, more closely resembling the pipeline flow of an actual pipeline, simulating the instructions moving between the different pipeline stages. It is likely to be the simplest approach to understand and implement, and modifications required from asynchronous events might be easier to apply. The time wheel approach, on the other hand, adopts a more abstract representation, focusing on what changes occur in each clock cycle. While this requires a complicated scheduler and more complicated handling of asynchronous events, the higher level of abstraction can be beneficial to avoid the simulator operating too closely to the RTL code, implementing the same bugs in both.

%An important consideration is how the different approaches must be modeled to handle asynchronous events. In the time wheel approach, a single instruction and pipeline stage can have effects stored in multiple cycle slots. Additionally, a single cycle slot can also contain effects from multiple instructions. This can make it difficult to modify single stages or instructions, for instance, to flush a few pipeline stages when taking an interrupt.
%On the other hand, the stage-based approach keeps the stage intact, allowing us to halt or flush selected stages more easily.
%
%Another complication for the pipeline simulation is multicycle instructions. Using the CV32E40X core as an example, the longest instruction is the division operation and can last up to 35 cycles \cite{openhw_group_pipeline_2023}. To correctly model this in the time wheel approach, the scheduler needs to know the correct cycle count when inserting the instruction into the time wheel, and the time wheel must be large enough to hold all the cycles. In the stage-based design, this can be modeled by stalling the EX stage for the correct number of cycles, simplifying the design. 
%
%Because the stage-based design follows the flow of the RTL pipeline, stalls can be easily modeled since the preceding pipeline stage can signal if it can be updated, and if not, the following stage must stall. In the time wheel approach, the scheduler must determine beforehand if stalls are necessary and insert these into the time wheel.
%
%In summary, the stage-based approach might be the easiest approach to understand and implement, both for normal execution and for modifications due to asynchronous events. However, the different abstraction levels of the time wheel approach can be beneficial to avoid a simulator that too closely copies the core, implementing the same bugs in both. More work should go into further analyzing both, specifically determining how an asynchronous event can be modeled in both, as well as comparing the complexity details closely.

In \cref{sec:shell_iss_interaction}, we proposed three different approaches to how the pipeline shell could interact with the ISS. Approach 3 (\cref{sec:app3}) is the approach that requires the least amount of modifications to the ISS and should be generic enough so that the ISS interface can work for different cores with different amounts of pipeline stages. As discussed, this approach can also lead to a more simplified design, where we, for instance, do not have to simulate forwarding between the pipeline stages. To achieve accurate register and side effect updates, the approach proposes the use of a separate register file and CSR registers outside of the ISS, as this will allow the internal register file in the ISS to be used for correct functional execution, and the external to ensure proper timing of updates. Additionally, the contents of the external register file can be used to override the internal register file in the event of an asynchronous event requiring a pipeline flush. Further work should go into implementing this approach to verify that it allows correct cycle-accurate behavior and correct pipeline flushing.

We have also compared different ISSs to build the model on top of in \cref{sec:choosingISS} and found that, in theory, Spike seems like a good alternative. Spike can meet all the proposed requirements with only minor modifications. It is also stable, widely used, and versatile enough to fit into multiple of the proposed design approaches. Future work should go into implementing the necessary modifications in \cref{sec:spike_req} to determine if all the necessary requirements actually can be met. It should also be implemented into the reference model. More work should also be done to determine if there are any discrepancies in the interpretation of the ISA between Spike and the CV32E40X core. 

The field lacks much open research since processor verification is traditionally only done by a few mainstream IP suppliers that keep their verification techniques to themselves. This has also made gathering data and previous work to use as a basis for discussing the different approaches in the report difficult. Additionally, none of the approaches discussed have yet to be implemented in practice, other than the few examples from previous implementations. Therefore, the results and conclusions drawn in this report should only serve as a starting point for further investigation and the practical implementation of a reference model. The necessary further work is discussed below.

\section{Future work}
\label{sec:futureWork}

Future work should go into analyzing the dependency tree in \cref{fig:dependencyTree} and determining which simulation dependencies are required and which can be abstracted away to simplify the simulation. Another interesting experiment could be to make dependency trees for different processor cores, and compare which components are the same, and which are different.

Future work should be done with the dependency tree to determine if the stage-base pipeline from \cref{sec:stagebased} or the time wheel approach from \cref{sec:timeWheel} works best for simulating the necessary dependencies. Additionally, analysis should be done to determine how both approaches would react to asynchronous events. For instance, determining how the conditions for an interrupt can be found in each approach and how the pipeline can be flushed and jump to a new PC.
Further work can also be done to explore the viability of a legal state exploration approach, similar to ImperasDV.


Spike should also be modified and integrated into a model following approach 3 from \cref{sec:app3}, using an external register file and CSR registers. Furthermore, experiments should be done to verify that pipeline flushing and jumping to a different PC functions correctly by reverting the ISS state with the external register file and CSRs. Spike should also be modified to export functions that allow Spike to take interrupts. Additionally, work should be done to determine if there are any discrepancies between the RISC-V implementation of Spike and the DUT core. 

The proposed reference model should be implemented in practice with the chosen implementation strategies from above. The reference model should be evaluated to ensure its accuracy. This can be done by running it in parallel to a DUT that is already verified. This way, the divergences found will likely be faults in the reference model.